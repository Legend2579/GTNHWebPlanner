<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GTNH Recipe Planner</title>
<style>
  :root {
    --bg: #0e1116;
    --panel: #161b22;
    --text: #e6edf3;
    --muted: #9aa6b2;
    --border: #30363d;
    --accent: #2ea043;
    --accent-contrast: #052010;
    --blue: #58a6ff;
    --warn: #f0883e;
    --danger: #f85149;
    --yellow: #d29922;

    /* ACTIVE styling */
    --active: #58a6ff;
    --active-bg: rgba(88,166,255,.14);
    --active-border: rgba(88,166,255,.45);

    /* IDEAL styling (orange) */
    --ideal: #f0883e;
    --ideal-bg: rgba(240,136,62,.14);
    --ideal-border: rgba(240,136,62,.45);

    /* MATCH styling (ACTIVE == IDEAL) */
    --match: #2ea043;
    --match-bg: rgba(46,160,67,.14);
    --match-border: rgba(46,160,67,.45);
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body { margin: 0; background: var(--bg); color: var(--text);
    font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; }
  header.appbar { position: sticky; top: 0; background: #0d1117; border-bottom: 1px solid var(--border);
    padding: 8px; display: flex; gap: 8px; align-items: center; z-index: 5; flex-wrap: wrap; }
  header.appbar h1 { margin: 0 8px 0 0; font-size: 16px; font-weight: 600; }
  .spacer { flex: 1; }
  button, input, select, textarea { background: #0d1117; color: var(--text); border: 1px solid var(--border);
    border-radius: 8px; padding: 6px 10px; }
  button { cursor: pointer; }
  button.primary { background: var(--accent); color: var(--accent-contrast); border-color: var(--accent); }
  button.ghost { background: transparent; border-color: var(--border); }
  button.icon { padding: 4px 6px; }
  input[type="number"] { width: 7ch; }
  input[type="search"] { width: 100%; }
  .pill { display: inline-flex; gap: 6px; align-items: center; padding: 2px 8px; background: #0d1117; border: 1px solid var(--border); border-radius: 999px; }
  .muted { color: var(--muted); }
  .warn { color: var(--warn); }
  .accent { color: var(--accent); }
  .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }

  #app { display: grid; gap: 8px; padding: 8px; grid-template-columns: 320px 1fr 400px; }
  .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 10px; display: flex; flex-direction: column; min-height: 120px; overflow: hidden; }
  .panel .head { padding: 8px 12px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 8px; }
  .panel .body { padding: 8px 12px; overflow: auto; flex: 1; }

  .list { list-style: none; margin: 0; padding: 0; }
  .list li { display: flex; justify-content: space-between; gap: 8px; align-items: center; padding: 8px; border-bottom: 1px solid #21262d; }
  .list li:hover { background: #0d1117; }
  .row { display: flex; gap: 8px; align-items: center; }
  .row.space { justify-content: space-between; }
  .tag { display: inline-block; padding: 0 6px; border: 1px solid var(--border); border-radius: 6px; background: #0d1117; }
  .tag.warn { border-color: #3c2c16; color: var(--warn); }

  /* Tags for ACTIVE / IDEAL / MATCH */
  .tag.active { border-color: var(--active-border); color: var(--active); background: var(--active-bg); }
  .tag.ideal  { border-color: var(--ideal-border);  color: var(--ideal);  background: var(--ideal-bg); }
  .tag.match  { border-color: var(--match-border);  color: var(--match);  background: var(--match-bg); }

  /* Missing (only ACTIVE or only IDEAL) */
  .tag.missing { border-color: rgba(248,81,73,.55); color: var(--danger); background: rgba(248,81,73,.10); }

  .tree ul { list-style: none; margin: 0; padding-left: 14px; border-left: 1px dashed var(--border); }
  .tree li { margin: 6px 0; }
  .node { display: grid; grid-template-columns: auto auto 1fr auto; gap: 8px; align-items: center; }
  .toggle { width: 1.1rem; text-align: center; cursor: pointer; user-select: none; }
  .fav { cursor: pointer; }

  .help { padding: 8px 12px; border-top: 1px dashed var(--border); }
  .sep { height: 1px; background: #21262d; margin: 8px 0; }

  #progressBar { width: 260px; height: 10px; background: #1b2230; border: 1px solid var(--border); border-radius: 6px; overflow: hidden; }
  #progressBar .fill { height: 100%; width: 0%; background: var(--blue); transition: width .12s linear; }
  .choose-btn { border-color: #3c2c16; color: var(--warn); }

  .tabs { display: inline-flex; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
  .tabs button { border: 0; padding: 6px 10px; background: #0d1117; }
  .tabs button.active { background: #0f1420; color: var(--text); border-right: 1px solid var(--border); }
  .tabs button + button { border-left: 1px solid var(--border); }

  /* Favorites filters row */
  .favFilters { display:flex; gap:6px; flex-wrap:wrap; margin: 0 0 6px 0; }
  .favFilters button.active { box-shadow: inset 0 0 0 2px rgba(88,166,255,.22); border-color: rgba(88,166,255,.45); }

  #todoArea .level-title { font-weight: 600; margin-top: 8px; padding-top: 8px; border-top: 1px solid #21262d; }
  #todoArea .level-title .levelHeader { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  #todoArea .level-title .levelToggle { width: 28px; text-align:center; }
  #todoArea .level-title .levelToggle button { padding: 4px 8px; }
  #todoArea .step { display: grid; grid-template-columns: 1fr auto; gap: 8px; padding: 8px 10px; border-bottom: 1px dashed #21262d; border-radius: 8px; }
  #todoArea .step.checked-storage { background: #0f1f16; box-shadow: inset 0 0 0 2px rgba(46,160,67,.35); }
  #todoArea .step.craftable-now { background: #132616; box-shadow: inset 0 0 0 2px rgba(46,160,67,.55); }
  #todoArea .step.partially-craftable { background: #251f10; box-shadow: inset 0 0 0 2px rgba(240,136,62,.55); }
  #todoArea .step.ingredient-focus { outline: 2px solid var(--yellow); outline-offset: -2px; background-image: linear-gradient(0deg, rgba(210,153,34,.12), rgba(210,153,34,.12)); }
  #todoArea .meta { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; cursor: pointer; }
  #todoArea .right { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  #todoArea label.small { color: var(--muted); font-size: 12px; display: inline-flex; gap: 6px; align-items: center; user-select:none; }
  #todoArea input.owned { width: 8ch; }

  #gatherSummary li.gather-done { background: #132616; box-shadow: inset 0 0 0 2px rgba(46,160,67,.55); border-radius: 8px; }

  .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.5); display: none; align-items: center; justify-content: center; z-index: 9998; }
  .modal { background: #0d1117; border: 1px solid var(--border); border-radius: 10px; max-width: 680px; width: min(96vw, 680px); max-height: 80vh; display: flex; flex-direction: column; }
  .modal .mod-head { padding: 10px 12px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 8px; }
  .modal .mod-body { padding: 10px 12px; overflow: auto; display: flex; flex-direction: column; gap: 8px; }
  .modal .mod-foot { padding: 10px 12px; border-top: 1px solid var(--border); display: flex; gap: 8px; justify-content: flex-end; }

  /* Dropdown highlighting (native selects) */
  select.ideal-selected { outline: 2px solid var(--ideal); outline-offset: 0px; background-image: linear-gradient(0deg, var(--ideal-bg), var(--ideal-bg)); }
  select.active-selected { outline: 2px solid var(--active); outline-offset: 0px; background-image: linear-gradient(0deg, var(--active-bg), var(--active-bg)); }
  select.match-selected  { outline: 2px solid var(--match); outline-offset: 0px; background-image: linear-gradient(0deg, var(--match-bg), var(--match-bg)); }

  /* Two-star buttons */
  .starbtn { font-weight: 700; line-height: 1; padding: 4px 8px; }
  .starbtn.activeStar { color: var(--active); border-color: var(--active-border); background: var(--active-bg); }
  .starbtn.idealStar  { color: var(--ideal);  border-color: var(--ideal-border);  background: var(--ideal-bg); }
  .starbtn.matchStar  { color: var(--match);  border-color: var(--match-border);  background: var(--match-bg); }

  /* Recipe chooser modal selection highlighting */
  .recipe-row { border-bottom: 1px dashed #21262d; padding: 6px 4px; }
  .recipe-row.selected-active { color: var(--active); background: var(--active-bg); border-radius: 8px; }
  .recipe-row.selected-ideal  { color: var(--ideal);  background: var(--ideal-bg);  border-radius: 8px; }
  .recipe-row.selected-match  { color: var(--match);  background: var(--match-bg);  border-radius: 8px; }
  .recipe-row.selected-active .muted,
  .recipe-row.selected-ideal .muted,
  .recipe-row.selected-match .muted { color: inherit; opacity: .95; }

  /* =========================================================
     WRAPPING RECIPE DROPDOWN (custom combobox)
     ========================================================= */
  .combo { position: relative; min-width: 420px; flex: 1; max-width: 100%; }
  .comboBtn{
    width:100%;
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:6px 10px;
    background:#0d1117; border:1px solid var(--border); border-radius:8px;
    text-align:left;
  }
  .comboBtn:focus{ outline:2px solid rgba(88,166,255,.45); outline-offset:0 }
  .comboBtn .label{
    flex:1; min-width:0;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }
  .comboBtn .caret{ opacity:.85 }
  .comboBtn.active-selected{ outline:2px solid var(--active); background-image:linear-gradient(0deg,var(--active-bg),var(--active-bg)); }
  .comboBtn.ideal-selected { outline:2px solid var(--ideal);  background-image:linear-gradient(0deg,var(--ideal-bg),var(--ideal-bg)); }
  .comboBtn.match-selected { outline:2px solid var(--match);  background-image:linear-gradient(0deg,var(--match-bg),var(--match-bg)); }

  .comboMenu{
    position:absolute; left:0; right:0; top:calc(100% + 6px);
    background:#0d1117;
    border:1px solid var(--border);
    border-radius:10px;
    box-shadow:0 14px 40px rgba(0,0,0,.55);
    z-index:9997;
    max-height:min(55vh, 520px);
    overflow:auto;
    padding:6px;
    display:none;
  }
  .comboMenu.open{ display:block }
  .comboItem{
    display:flex; gap:8px; align-items:flex-start; justify-content:space-between;
    padding:8px 10px; border-radius:8px; cursor:pointer;
  }
  .comboItem:hover{ background:#0f1420 }
  .comboItem[aria-selected="true"]{ background:#0f1f16; box-shadow: inset 0 0 0 2px rgba(46,160,67,.35); }
  .comboItem .text{
    flex:1; min-width:0;
    white-space:normal;
    overflow-wrap:anywhere;
    word-break:break-word;
    line-height:1.35;
  }
  .comboItem .mark{ flex:0 0 auto }
  .comboItem .mark .tag{ margin-left:6px }
  .comboHint{
    font-size:12px; color:var(--muted); margin-top:6px;
    white-space:normal; overflow-wrap:anywhere;
  }
  .kbd{ border:1px solid var(--border); background:#0f1420; border-radius:6px; padding:0 6px; font-size:12px }

  /* =========================
     Resizable columns (splitters)
     ========================= */
  :root{
    --col-left: 320px;
    --col-right: 400px;
    --splitter-w: 10px;
  }

  #app{
    grid-template-columns: var(--col-left) 1fr var(--col-right);
  }

  .panel .head{
    position: relative;
  }

  .splitter{
    position:absolute;
    top:0; bottom:0;
    width: var(--splitter-w);
    cursor: col-resize;
    z-index: 20;
    background: transparent;
  }

  .splitter.at-left-edge{
    left: calc(-1 * (var(--splitter-w) / 2));
  }

  .splitter:hover{ background: rgba(88,166,255,.08); }
  .splitter:active{ background: rgba(88,166,255,.14); }

  body.resizing-cols{
    cursor: col-resize !important;
    user-select: none !important;
  }

  /* =========================
     Remaining-to-gather filters
     ========================= */
  .gatherFilters{
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    margin-top:6px;
  }
  .gatherFilters label{
    color: var(--muted);
    font-size: 12px;
    display:inline-flex;
    gap:6px;
    align-items:center;
    user-select:none;
  }
</style>
</head>
<body>

<header class="appbar">
  <h1>GTNH Recipe Planner</h1>
  <input type="file" id="fileInput" accept=".zip,application/zip,application/x-zip-compressed,application/json,.json,.json.gz" />
  <button id="btnLoadDemo" class="ghost">Load demo</button>
  <div class="row" title="In GregTech machines, the Programmed Circuit is usually not consumed.">
    <label class="row">
      <input type="checkbox" id="chkConsumeCircuits" />
      <span>Consume GT Programmed Circuits</span>
    </label>
  </div>
  <div class="spacer"></div>
  <button id="btnToggleCatalog" class="ghost">Hide Catalog</button>
  <button id="btnTogglePlan" class="ghost">Hide Plan</button>
  <div id="progressWrap" class="row" style="display:none">
    <div id="progressText" class="muted">Importing…</div>
    <div id="progressBar"><div class="fill"></div></div>
  </div>
</header>

<div id="app">
  <section class="panel" id="catalogPanel">
    <div class="head">
      <strong>Catalog</strong>
      <div class="spacer"></div>
      <div class="tabs">
        <button id="tabCatalog" class="active">Catalog</button>
        <button id="tabFavorites">Favorites</button>
      </div>
    </div>
    <div class="body">
      <div id="catalogView">
        <div class="row" style="margin-bottom:6px;">
          <input id="searchBox" type="search" placeholder="Search items (name, id, or meta id)" />
        </div>
        <ul id="catalogList" class="list" aria-live="polite"></ul>
      </div>
      <div id="favoritesView" style="display:none;">
        <div class="row" style="margin-bottom:6px;">
          <button id="btnExportFavorites" class="ghost">Export favorites</button>
          <input type="file" id="favImport" accept="application/json" style="display:none" />
          <button id="btnImportFavorites" class="ghost">Import favorites</button>
          <button id="btnClearFavorites" class="ghost">Clear favorites</button>
        </div>

        <div class="row" style="margin-bottom:6px;">
          <button id="btnExportIdeal" class="ghost" title="Export IDEAL favorites (bookmarks).">Export ideal</button>
          <input type="file" id="idealImport" accept="application/json" style="display:none" />
          <button id="btnImportIdeal" class="ghost" title="Import IDEAL favorites (bookmarks).">Import ideal</button>
          <button id="btnClearIdeal" class="ghost" title="Clear IDEAL favorites only.">Clear ideal</button>
        </div>

        <div class="favFilters" id="favFilters">
          <button id="btnFavFilterAll" class="ghost">All</button>
          <button id="btnFavFilterGreen" class="ghost">Green (MATCH)</button>
          <button id="btnFavFilterBlue" class="ghost">Blue (ACTIVE≠IDEAL)</button>
          <button id="btnFavFilterMissing" class="ghost">Missing (red)</button>
        </div>

        <div style="display:flex; flex-direction:column; gap:6px; margin-bottom:6px;">
          <input id="favSearchOutput" type="search" placeholder="Search favorited items (output name)…" />
          <input id="favSearchIngredient" type="search" placeholder="Search by ingredient used in recipe…" />
        </div>
        <ul id="favoritesList" class="list" aria-live="polite"></ul>
      </div>
    </div>
  </section>

  <section class="panel" id="inspectorPanel">
    <div class="head">
      <strong>Inspector</strong>
      <span id="inspectorTitle" class="muted"></span>
      <div class="spacer"></div>
      <div id="splitLeft" class="splitter at-left-edge" title="Drag to resize Catalog"></div>
      <button id="btnClearSelection" class="ghost">Clear</button>
    </div>
    <div class="body" id="inspectorBody">
      <div class="sep"></div>
      <div id="recipeArea"></div>
      <div class="sep"></div>
      <div id="todoArea"></div>
    </div>
  </section>

  <section class="panel" id="planPanel">
    <div class="head">
      <strong>Plan</strong>
      <div id="splitRight" class="splitter at-left-edge" title="Drag to resize Plan"></div>
      <div class="spacer"></div>

      <button id="btnHiddenItems" class="ghost">Hidden Items (0)</button>
      <!-- NEW -->
      <button id="btnBaseItems" class="ghost">Base Items (0)</button>

      <button id="btnExportState" class="ghost">Export state</button>
      <input type="file" id="stateImport" accept="application/json" style="display:none" />
      <button id="btnImportState" class="ghost">Import state</button>
      <button id="btnClearPlan" class="ghost">Clear plan</button>
    </div>
    <div class="body">
      <div id="targetsArea"></div>
      <div class="sep"></div>
      <div id="gatherSummary"></div>
      <div class="sep"></div>
      <div class="tree" id="treeArea"></div>
    </div>
    <div class="help">
      <div><strong>Notes</strong></div>
      <ul>
        <li>ACTIVE favorites affect planning. IDEAL favorites are bookmarks only.</li>
        <li>Owned/Checked/Hidden reset on refresh unless you enable “Persist Owned/Checked & hidden” in the To‑do toolbar.</li>
        <li>Programmed Circuits are hidden from “Remaining to gather.”</li>
        <li>To‑do is leveled (base=1 → final=max; grouped by machine, then name).</li>
      </ul>
    </div>
  </section>
</div>

<div id="modalBackdrop" class="modal-backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modTitle">
    <div class="mod-head">
      <strong id="modTitle">Choose</strong>
      <div class="spacer"></div>
      <button id="modClose" class="icon" title="Close">✕</button>
    </div>
    <div class="mod-body" id="modBody"></div>
    <div class="mod-foot" id="modFoot"></div>
  </div>
</div>

<script type="module">
const supportsDecompressionStream = typeof DecompressionStream !== "undefined";

// Progress
const progressWrap = document.getElementById("progressWrap");
const progressText = document.getElementById("progressText");
const progressFill = document.querySelector("#progressBar .fill");
function showProgress(label, frac) { progressWrap.style.display = "flex"; progressText.textContent = label; if (Number.isFinite(frac)) progressFill.style.width = (frac * 100).toFixed(0) + "%"; }
function hideProgress() { progressWrap.style.display = "none"; progressFill.style.width = "0%"; }

// Utilities
const uid = (() => { let i = 0; return () => (++i).toString(36) + "-" + Date.now().toString(36); })();
const keyOf = (id, meta = 0) => meta ? `${id}@${meta}` : id;
const ceilDiv = (a, b) => Math.ceil(a / b);
function hashCode(str) { let h = 0; for (let i = 0; i < str.length; i++) { h = Math.imul(31, h) + str.charCodeAt(i) | 0; } return h; }
function stableHashHex(str){ const h = hashCode(str) >>> 0; return ("00000000" + h.toString(16)).slice(-8); }
function isFluidKey(key){ return String(key || "").startsWith("fluid:"); }
function stepForKey(key){ return isFluidKey(key) ? 1000 : 1; }

// stack formatting toggle
function isItemKey(key){ return !(String(key||"").startsWith("fluid:") || String(key||"").startsWith("tag:")); }
function fmtStacks(n, stack=64){
  const v = Math.max(0, Math.floor(Number(n)||0));
  const s = Math.floor(v / stack);
  const r = v % stack;
  if (s <= 0) return String(r);
  if (r === 0) return `${s}x${stack}`;
  return `${s}x${stack} + ${r}`;
}

// LocalStorage
const LS = { get(k, f){ try{ const v = localStorage.getItem(k); return v ? JSON.parse(v) : f; }catch{ return f; }}, set(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch{} } };
const LS_KEYS = {
  favorites: "gtnh_favorites",
  favoritesIdeal: "gtnh_favorites_ideal",
  tagPrefs: "gtnh_tag_prefs",
  recipeTagPrefs: "gtnh_tag_prefs_by_recipe",
  plan: "gtnh_plan_targets",
  circuitsConsumed: "gtnh_circuits_consumed",
  baseOverrides: "gtnh_base_overrides",
  leftTab: "gtnh_left_tab",
  collapsedCatalog: "gtnh_collapsed_catalog",
  collapsedPlan: "gtnh_collapsed_plan",
  colSizes: "gtnh_col_sizes",
  favFilter: "gtnh_fav_filter",

  // To-do
  todoReverse: "gtnh_todo_reverse",
  todoFilterCraftable: "gtnh_todo_filter_craftable_now",
  todoFilterHideChecked: "gtnh_todo_filter_hide_checked",
  todoCollapsedLevels: "gtnh_todo_collapsed_levels",

  // Persist session (Owned/Checked/Hidden)
  sessionPersist: "gtnh_session_persist_enabled",
  obtained: "gtnh_obtained_map",
  checkedStorage: "gtnh_checked_storage_set",
  gatherHiddenKeys: "gtnh_gather_hidden_keys_set",

  // permanent hidden list (always persisted)
  gatherHiddenKeysPermanent: "gtnh_gather_hidden_keys_permanent",

  // gather filter checkboxes persisted + act like hiding
  gatherHideFilters: "gtnh_gather_hide_filters",

  // stack formatting toggle
  qtyAsStacks: "gtnh_qty_as_stacks"
};

// Store
class Store {
  constructor() {
    this.items = new Map();
    this.tags = new Map();
    this.recipes = new Map();
    this.byOutput = new Map();
  }
  clear() { this.items.clear(); this.tags.clear(); this.recipes.clear(); this.byOutput.clear(); }
  importNormalized(doc) {
    this.clear();
    if (Array.isArray(doc.items)) for (const it of doc.items) {
      const key = keyOf(it.id, it.meta ?? 0);
      const name = it.displayName || it.id + ((it.meta ?? 0) ? ` [${it.meta}]` : "");
      this.items.set(key, { id: it.id, meta: it.meta || 0, name, metaId: (typeof it.metaId === "number" ? it.metaId : undefined) });
    }
    if (doc.tags && typeof doc.tags==="object")
      for (const [tag, arr] of Object.entries(doc.tags))
        this.tags.set(tag, (arr||[]).map(s=> typeof s==="string"? s : keyOf(s.id, s.meta||0)));
    if (Array.isArray(doc.recipes))
      for (const r of doc.recipes) {
        this.recipes.set(r.id, r);
        for (const o of r.outputs) {
          const outKey = o.key || keyOf(o.item, o.meta||0);
          if (!this.byOutput.has(outKey)) this.byOutput.set(outKey, []);
          this.byOutput.get(outKey).push(r.id);
        }
      }
  }
  getItemName(key) {
    if (this.items.has(key)) return this.items.get(key).name;
    if (key.startsWith("fluid:")) return key.slice(6).replace(/_/g," ")+" (mB)";
    if (key.startsWith("tag:")) return `Tag: ${key.slice(4)}`;
    return key;
  }
  getMetaId(key) {
    const it = this.items.get(key);
    if (!it) return undefined;
    if (typeof it.metaId === "number") return it.metaId;
    if (typeof it.meta === "number" && it.meta > 0) return it.meta;
    return 0;
  }
  outputsFor(key) { return this.byOutput.get(key) || []; }
  getRecipe(id) { return this.recipes.get(id); }
}
const store = new Store();

// Formatting
let qtyAsStacks = !!LS.get(LS_KEYS.qtyAsStacks, false);
function fmtQty(n, keyForMode=null) {
  if (!Number.isFinite(n)) n = 0;
  const v = Math.max(0, Math.floor(Number(n)||0));
  const useStacks = qtyAsStacks && keyForMode && isItemKey(keyForMode);
  if (useStacks) return fmtStacks(v, 64);
  return (Math.abs(v) >= 10000 ? v.toLocaleString() : String(v));
}

// State
const favorites = new Map(Object.entries(LS.get(LS_KEYS.favorites, {})));
const favoritesIdeal = new Map(Object.entries(LS.get(LS_KEYS.favoritesIdeal, {})));

const legacyTagPrefs = new Map(Object.entries(LS.get(LS_KEYS.tagPrefs, {})));
const recipeTagPrefs = new Map(Object.entries(LS.get(LS_KEYS.recipeTagPrefs, {})).map(([fk, obj]) => [fk, new Map(Object.entries(obj))]));
let planTargets = LS.get(LS_KEYS.plan, []);
let circuitsConsumed = !!LS.get(LS_KEYS.circuitsConsumed, false);
const baseOverrides = new Set(LS.get(LS_KEYS.baseOverrides, []));
let leftTab = LS.get(LS_KEYS.leftTab, "catalog");
let collapsedCatalog = !!LS.get(LS_KEYS.collapsedCatalog, false);
let collapsedPlan = !!LS.get(LS_KEYS.collapsedPlan, false);

let favoritesFilter = LS.get(LS_KEYS.favFilter, "all");

// To-do state
let todoReverse = !!LS.get(LS_KEYS.todoReverse, false);
let todoFilterCraftableNow = !!LS.get(LS_KEYS.todoFilterCraftable, false);
let todoFilterHideChecked = !!LS.get(LS_KEYS.todoFilterHideChecked, false);
let todoCollapsedLevels = new Set((LS.get(LS_KEYS.todoCollapsedLevels, []) || []).map(x => Number(x)).filter(n => Number.isFinite(n)));

let sessionPersistEnabled = !!LS.get(LS_KEYS.sessionPersist, false);

// Session data
let obtained = new Map();
let checkedStorage = new Set();

// Hidden list is permanent (always persisted)
let gatherHiddenKeys = new Set(Array.isArray(LS.get(LS_KEYS.gatherHiddenKeysPermanent, [])) ? LS.get(LS_KEYS.gatherHiddenKeysPermanent, []) : []);

let gatherMarked = new Set();
let ingredientFocusKey = null;

// Gather filter checkboxes persisted
let gatherHideFilters = LS.get(LS_KEYS.gatherHideFilters, { hideMolds:false, hideExtruderShapes:false });
if (!gatherHideFilters || typeof gatherHideFilters !== "object") gatherHideFilters = { hideMolds:false, hideExtruderShapes:false };
gatherHideFilters.hideMolds = !!gatherHideFilters.hideMolds;
gatherHideFilters.hideExtruderShapes = !!gatherHideFilters.hideExtruderShapes;

// Load session from storage if enabled (Owned/Checked only)
hydrateSessionFromStorage();

// DOM refs
const fileInput = document.getElementById("fileInput");
const btnLoadDemo = document.getElementById("btnLoadDemo");
const chkConsumeCircuits = document.getElementById("chkConsumeCircuits");
chkConsumeCircuits.checked = circuitsConsumed;

const btnToggleCatalog = document.getElementById("btnToggleCatalog");
const btnTogglePlan = document.getElementById("btnTogglePlan");

const catalogPanel = document.getElementById("catalogPanel");
const planPanel = document.getElementById("planPanel");

const tabCatalog = document.getElementById("tabCatalog");
const tabFavorites = document.getElementById("tabFavorites");
const catalogView = document.getElementById("catalogView");
const favoritesView = document.getElementById("favoritesView");

const searchBox = document.getElementById("searchBox");
const catalogList = document.getElementById("catalogList");
const favoritesList = document.getElementById("favoritesList");
const btnExportFavorites = document.getElementById("btnExportFavorites");
const btnImportFavorites = document.getElementById("btnImportFavorites");
const favImport = document.getElementById("favImport");
const btnClearFavorites = document.getElementById("btnClearFavorites");

const btnExportIdeal = document.getElementById("btnExportIdeal");
const btnImportIdeal = document.getElementById("btnImportIdeal");
const idealImport = document.getElementById("idealImport");
const btnClearIdeal = document.getElementById("btnClearIdeal");

const favSearchOutput = document.getElementById("favSearchOutput");
const favSearchIngredient = document.getElementById("favSearchIngredient");

// Favorites filter buttons
const btnFavFilterAll = document.getElementById("btnFavFilterAll");
const btnFavFilterGreen = document.getElementById("btnFavFilterGreen");
const btnFavFilterBlue = document.getElementById("btnFavFilterBlue");
const btnFavFilterMissing = document.getElementById("btnFavFilterMissing");

const inspectorTitle = document.getElementById("inspectorTitle");
const recipeArea = document.getElementById("recipeArea");
const todoArea = document.getElementById("todoArea");
const btnClearSelection = document.getElementById("btnClearSelection");

const targetsArea = document.getElementById("targetsArea");
const gatherSummary = document.getElementById("gatherSummary");
const treeArea = document.getElementById("treeArea");
const btnClearPlan = document.getElementById("btnClearPlan");

const btnHiddenItems = document.getElementById("btnHiddenItems");
// NEW
const btnBaseItems = document.getElementById("btnBaseItems");

// ===== Helpers for ACTIVE/IDEAL/MATCH/MISSING =====
function favPairFor(outKey) {
  const activeId = favorites.get(outKey) || null;
  const idealId = favoritesIdeal.get(outKey) || null;
  const match = !!(activeId && idealId && activeId === idealId);
  const missing = (!!activeId) !== (!!idealId);
  const bothSet = !!(activeId && idealId);
  const blue = bothSet && !match;
  return { activeId, idealId, match, missing, blue, bothSet };
}
function applyStarBtnClass(btn, mode, match) {
  btn.classList.remove("activeStar","idealStar","matchStar");
  if (match) btn.classList.add("matchStar");
  else btn.classList.add(mode === "ideal" ? "idealStar" : "activeStar");
}
function applySelectHighlight(selectEl, cls) {
  selectEl.classList.remove("ideal-selected","active-selected","match-selected");
  if (!cls) return;
  if (cls === "match") selectEl.classList.add("match-selected");
  else if (cls === "ideal") selectEl.classList.add("ideal-selected");
  else if (cls === "active") selectEl.classList.add("active-selected");
}
function machineTagClassForOutKey(outKey) {
  const p = favPairFor(outKey);
  if (p.missing) return "missing";
  return p.match ? "match" : "active";
}

// ===== Session persistence helpers (Owned / Checked only) =====
function hydrateSessionFromStorage() {
  if (!sessionPersistEnabled) {
    obtained = new Map();
    checkedStorage = new Set();
    return;
  }
  const rawObt = LS.get(LS_KEYS.obtained, {});
  const rawChk = LS.get(LS_KEYS.checkedStorage, []);

  obtained = new Map(Object.entries(rawObt || {}).map(([k,v]) => [k, Math.max(0, Math.floor(Number(v)||0))]));
  checkedStorage = new Set(Array.isArray(rawChk) ? rawChk : []);
}
function persistSessionNow() {
  if (!sessionPersistEnabled) return;
  const obj = {};
  for (const [k, v] of obtained.entries()) obj[k] = Math.max(0, Math.floor(Number(v)||0));
  LS.set(LS_KEYS.obtained, obj);
  LS.set(LS_KEYS.checkedStorage, Array.from(checkedStorage));
}
function persistHiddenNow(){
  LS.set(LS_KEYS.gatherHiddenKeysPermanent, Array.from(gatherHiddenKeys));
}
function persistGatherFiltersNow(){
  LS.set(LS_KEYS.gatherHideFilters, gatherHideFilters);
}
function setSessionPersistEnabled(next) {
  sessionPersistEnabled = !!next;
  LS.set(LS_KEYS.sessionPersist, sessionPersistEnabled);
  if (sessionPersistEnabled) persistSessionNow();
  toast(sessionPersistEnabled ? "Persistence enabled (Owned/Checked)" : "Persistence disabled (will reset on refresh)");
}
function setQtyAsStacksEnabled(next){
  qtyAsStacks = !!next;
  LS.set(LS_KEYS.qtyAsStacks, qtyAsStacks);
  renderAll();
  toast(qtyAsStacks ? "Qty format: stacks of 64 (items only)" : "Qty format: normal numbers");
}
function setObtainedValue(key, val) {
  obtained.set(key, Math.max(0, Math.floor(Number(val)||0)));
  persistSessionNow();
}
function bumpObtainedValue(key, delta) {
  const cur = obtainedNumber(key);
  const next = cur + Math.max(0, Math.floor(delta || 0));
  setObtainedValue(key, next);
}
function setCheckedStorageFlag(key, checked) {
  if (checked) checkedStorage.add(key);
  else checkedStorage.delete(key);
  persistSessionNow();
}
function setGatherHiddenFlag(key, hidden) {
  if (hidden) gatherHiddenKeys.add(key);
  else gatherHiddenKeys.delete(key);
  persistHiddenNow();
  updateHiddenItemsButton();
}

// Favorites filter UI
function updateFavFilterButtons(){
  const map = {
    all: btnFavFilterAll,
    match: btnFavFilterGreen,
    blue: btnFavFilterBlue,
    missing: btnFavFilterMissing
  };
  for (const [k, el] of Object.entries(map)) {
    if (!el) continue;
    el.classList.toggle("active", favoritesFilter === k);
  }
}
function setFavoritesFilter(next){
  favoritesFilter = next || "all";
  LS.set(LS_KEYS.favFilter, favoritesFilter);
  updateFavFilterButtons();
  renderFavoritesTab();
}
btnFavFilterAll?.addEventListener("click", () => setFavoritesFilter("all"));
btnFavFilterGreen?.addEventListener("click", () => setFavoritesFilter("match"));
btnFavFilterBlue?.addEventListener("click", () => setFavoritesFilter("blue"));
btnFavFilterMissing?.addEventListener("click", () => setFavoritesFilter("missing"));

// Layout controls
function computeGridColumns() {
  const w = window.innerWidth || document.documentElement.clientWidth;
  if (w <= 980) return "1fr";
  const leftW = (w <= 1200) ? 280 : 320;
  const rightW = (w <= 1200) ? 360 : 400;
  if (!collapsedCatalog && !collapsedPlan) return `${leftW}px 1fr ${rightW}px`;
  if (collapsedCatalog && !collapsedPlan) return `1fr ${rightW}px`;
  if (!collapsedCatalog && collapsedPlan) return `${leftW}px 1fr`;
  return "1fr";
}
function updateCollapseUI() {
  catalogPanel.style.display = collapsedCatalog ? "none" : "";
  planPanel.style.display = collapsedPlan ? "none" : "";
  btnToggleCatalog.textContent = collapsedCatalog ? "Show Catalog" : "Hide Catalog";
  btnTogglePlan.textContent = collapsedPlan ? "Show Plan" : "Hide Plan";
  document.getElementById("app").style.gridTemplateColumns = computeGridColumns();
  LS.set(LS_KEYS.collapsedCatalog, collapsedCatalog);
  LS.set(LS_KEYS.collapsedPlan, collapsedPlan);
}

/* Resizable columns */
const DEFAULT_COLS = { left: 320, right: 400 };
const MIN_LEFT = 220;
const MIN_RIGHT = 260;
const MIN_MID = 420;

let colSizes = LS.get(LS_KEYS.colSizes, DEFAULT_COLS);
if (!colSizes || typeof colSizes.left !== "number" || typeof colSizes.right !== "number") colSizes = { ...DEFAULT_COLS };

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function applyColumnSizes() {
  const app = document.getElementById("app");
  const w = window.innerWidth || document.documentElement.clientWidth;

  if (w <= 980) {
    app.style.gridTemplateColumns = "1fr";
    return;
  }

  if (collapsedCatalog || collapsedPlan) {
    app.style.gridTemplateColumns = computeGridColumns();
    return;
  }

  const maxLeft = Math.max(MIN_LEFT, w - MIN_RIGHT - MIN_MID);
  const maxRight = Math.max(MIN_RIGHT, w - MIN_LEFT - MIN_MID);

  colSizes.left = clamp(colSizes.left, MIN_LEFT, maxLeft);
  colSizes.right = clamp(colSizes.right, MIN_RIGHT, maxRight);

  app.style.gridTemplateColumns = `${Math.round(colSizes.left)}px 1fr ${Math.round(colSizes.right)}px`;
  LS.set(LS_KEYS.colSizes, colSizes);
}

function startDrag(which, startX) {
  const start = { ...colSizes };
  document.body.classList.add("resizing-cols");

  function onMove(ev) {
    const x = ev.clientX ?? (ev.touches && ev.touches[0]?.clientX);
    if (!Number.isFinite(x)) return;
    const dx = x - startX;

    if (which === "left") colSizes.left = start.left + dx;
    else if (which === "right") colSizes.right = start.right - dx;

    applyColumnSizes();
  }

  function onUp() {
    document.body.classList.remove("resizing-cols");
    window.removeEventListener("mousemove", onMove);
    window.removeEventListener("mouseup", onUp);
    window.removeEventListener("touchmove", onTouchMove, { passive: false });
    window.removeEventListener("touchend", onUp);
    LS.set(LS_KEYS.colSizes, colSizes);
  }

  function onTouchMove(e){ e.preventDefault(); onMove(e); }

  window.addEventListener("mousemove", onMove);
  window.addEventListener("mouseup", onUp);
  window.addEventListener("touchmove", onTouchMove, { passive: false });
  window.addEventListener("touchend", onUp);
}

const splitLeft = document.getElementById("splitLeft");
const splitRight = document.getElementById("splitRight");

splitLeft?.addEventListener("mousedown", (e) => {
  if (collapsedCatalog || collapsedPlan) return;
  e.preventDefault();
  startDrag("left", e.clientX);
});
splitRight?.addEventListener("mousedown", (e) => {
  if (collapsedCatalog || collapsedPlan) return;
  e.preventDefault();
  startDrag("right", e.clientX);
});
splitLeft?.addEventListener("touchstart", (e) => {
  if (collapsedCatalog || collapsedPlan) return;
  const x = e.touches?.[0]?.clientX;
  if (!Number.isFinite(x)) return;
  startDrag("left", x);
}, { passive: true });
splitRight?.addEventListener("touchstart", (e) => {
  if (collapsedCatalog || collapsedPlan) return;
  const x = e.touches?.[0]?.clientX;
  if (!Number.isFinite(x)) return;
  startDrag("right", x);
}, { passive: true });

window.addEventListener("resize", applyColumnSizes);
window.addEventListener("resize", () => { document.getElementById("app").style.gridTemplateColumns = computeGridColumns(); });

btnToggleCatalog.addEventListener("click", () => { collapsedCatalog = !collapsedCatalog; updateCollapseUI(); applyColumnSizes(); });
btnTogglePlan.addEventListener("click", () => { collapsedPlan = !collapsedPlan; updateCollapseUI(); applyColumnSizes(); });

// App events
btnLoadDemo.addEventListener("click", () => { store.importNormalized(DEMO_DATA); toast(`Loaded demo: ${store.items.size} items, ${store.recipes.size} recipes`); renderAll(); });
chkConsumeCircuits.addEventListener("change", () => { circuitsConsumed = chkConsumeCircuits.checked; LS.set(LS_KEYS.circuitsConsumed, circuitsConsumed); renderAll(); });

function setLeftTab(tab) {
  leftTab = tab; LS.set(LS_KEYS.leftTab, leftTab);
  tabCatalog.classList.toggle("active", tab === "catalog");
  tabFavorites.classList.toggle("active", tab === "favorites");
  catalogView.style.display = tab === "catalog" ? "" : "none";
  favoritesView.style.display = tab === "favorites" ? "" : "none";
  if (tab === "favorites") updateFavFilterButtons();
  renderLeftPane();
}
tabCatalog.addEventListener("click", () => setLeftTab("catalog"));
tabFavorites.addEventListener("click", () => setLeftTab("favorites"));

btnExportFavorites.addEventListener("click", () => {
  const data = JSON.stringify(Object.fromEntries(favorites), null, 2);
  downloadBlob(new Blob([data], { type: "application/json" }), "gtnh_favorites.json");
});
btnImportFavorites.addEventListener("click", () => favImport.click());
favImport.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  try {
    const text = await f.text(); const obj = JSON.parse(text);
    if (typeof obj !== "object" || Array.isArray(obj)) throw new Error("Invalid favorites file");
    favorites.clear(); for (const [k, v] of Object.entries(obj)) favorites.set(k, v);
    persistAll(); renderAll(); setLeftTab("favorites"); toast("Favorites imported");
  } catch (err) { alert("Import failed: " + err.message); }
});
btnClearFavorites.addEventListener("click", () => {
  if (!favorites.size) return;
  if (!confirm("Clear all saved recipe selections (ACTIVE)?")) return;
  favorites.clear(); persistAll(); renderAll(); setLeftTab("favorites");
});

btnExportIdeal.addEventListener("click", () => {
  const data = JSON.stringify(Object.fromEntries(favoritesIdeal), null, 2);
  downloadBlob(new Blob([data], { type: "application/json" }), "gtnh_ideal_favorites.json");
});
btnImportIdeal.addEventListener("click", () => idealImport.click());
idealImport.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  try {
    const text = await f.text(); const obj = JSON.parse(text);
    if (typeof obj !== "object" || Array.isArray(obj)) throw new Error("Invalid ideal favorites file");
    favoritesIdeal.clear(); for (const [k, v] of Object.entries(obj)) favoritesIdeal.set(k, v);
    persistAll(); renderAll(); setLeftTab("favorites"); toast("Ideal favorites imported");
  } catch (err) { alert("Import failed: " + err.message); }
});
btnClearIdeal.addEventListener("click", () => {
  if (!favoritesIdeal.size) return;
  if (!confirm("Clear all IDEAL favorites (bookmarks only)?")) return;
  favoritesIdeal.clear(); persistAll(); renderAll(); setLeftTab("favorites");
});

btnClearSelection.addEventListener("click", () => { planner.selectedKey = null; renderInspector(); });

btnClearPlan.addEventListener("click", () => {
  // hidden list is permanent and not cleared here
  if (!planTargets.length && obtained.size === 0 && checkedStorage.size === 0 && gatherMarked.size === 0) return;
  if (!confirm("Clear the entire plan and Owned/Checked state? (Hidden list is kept)")) return;

  planTargets = [];
  obtained.clear();
  checkedStorage.clear();
  gatherMarked.clear();
  ingredientFocusKey = null;

  persistAll();
  renderAll();
});

searchBox.addEventListener("input", () => renderCatalog());
document.getElementById("favSearchOutput")?.addEventListener("input", renderFavoritesTab);
document.getElementById("favSearchIngredient")?.addEventListener("input", renderFavoritesTab);

fileInput.addEventListener("change", async (e) => {
  const file = e.target.files?.[0]; if (!file) return;
  try { await importRecExFile(file); }
  catch (err) { alert("Import failed: " + err.message); console.error(err); }
  finally { hideProgress(); }
});

// Persistence (non-session + session toggle + todo UI state)
function persistAll() {
  LS.set(LS_KEYS.favorites, Object.fromEntries(favorites));
  LS.set(LS_KEYS.favoritesIdeal, Object.fromEntries(favoritesIdeal));
  LS.set(LS_KEYS.tagPrefs, Object.fromEntries(legacyTagPrefs));
  const rtpo = {}; for (const [fk, map] of recipeTagPrefs.entries()) rtpo[fk] = Object.fromEntries(map);
  LS.set(LS_KEYS.recipeTagPrefs, rtpo);
  LS.set(LS_KEYS.plan, planTargets);
  LS.set(LS_KEYS.circuitsConsumed, circuitsConsumed);
  LS.set(LS_KEYS.baseOverrides, Array.from(baseOverrides));
  LS.set(LS_KEYS.leftTab, leftTab);
  LS.set(LS_KEYS.collapsedCatalog, collapsedCatalog);
  LS.set(LS_KEYS.collapsedPlan, collapsedPlan);
  LS.set(LS_KEYS.colSizes, colSizes);
  LS.set(LS_KEYS.favFilter, favoritesFilter);

  // To-do
  LS.set(LS_KEYS.todoReverse, todoReverse);
  LS.set(LS_KEYS.todoFilterCraftable, todoFilterCraftableNow);
  LS.set(LS_KEYS.todoFilterHideChecked, todoFilterHideChecked);
  LS.set(LS_KEYS.todoCollapsedLevels, Array.from(todoCollapsedLevels));

  // session toggle + Owned/Checked session data
  LS.set(LS_KEYS.sessionPersist, sessionPersistEnabled);
  persistSessionNow();

  // permanent hidden + gather filters + qty formatting
  persistHiddenNow();
  persistGatherFiltersNow();
  LS.set(LS_KEYS.qtyAsStacks, qtyAsStacks);
}

/* Tag prefs */
const favKeyFor = (outKey, recipeId) => `${outKey}||${recipeId}`;
function getRecipeTagChoice(outKey, recipeId, tagName) {
  const fk = favKeyFor(outKey, recipeId);
  const map = recipeTagPrefs.get(fk);
  if (map && map.has(tagName)) return map.get(tagName);
  if (legacyTagPrefs.has(tagName)) return legacyTagPrefs.get(tagName);
  const list = store.tags.get(tagName) || [];
  return list[0] || null;
}
function setRecipeTagChoice(outKey, recipeId, tagName, itemKey) {
  const fk = favKeyFor(outKey, recipeId);
  if (!recipeTagPrefs.has(fk)) recipeTagPrefs.set(fk, new Map());
  const map = recipeTagPrefs.get(fk);
  if (itemKey) map.set(tagName, itemKey); else map.delete(tagName);
  if (map.size === 0) recipeTagPrefs.delete(fk);
  persistAll();
}

// Combo box
function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function createRecipeComboBox({ placeholder="— Select a recipe —" } = {}){
  const root = document.createElement("div");
  root.className = "combo";
  root.setAttribute("role","combobox");
  root.setAttribute("aria-expanded","false");

  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = "comboBtn";
  btn.innerHTML = `<span class="label">${escapeHtml(placeholder)}</span><span class="caret">▾</span>`;
  root.appendChild(btn);

  const menu = document.createElement("div");
  menu.className = "comboMenu";
  menu.setAttribute("role","listbox");
  root.appendChild(menu);

  const hint = document.createElement("div");
  hint.className = "comboHint";
  hint.innerHTML = `Tip: <span class="kbd">↑</span>/<span class="kbd">↓</span> then <span class="kbd">Enter</span>. Long lines wrap in this list.`;
  root.appendChild(hint);

  let items = [];
  let value = "";
  let open = false;
  let activeIndex = -1;

  function render(){
    const labelSpan = btn.querySelector(".label");
    const selectedItem = items.find(x=>x.value===value);
    labelSpan.textContent = selectedItem ? selectedItem.label : placeholder;
    btn.title = selectedItem ? selectedItem.label : "";

    menu.innerHTML = "";

    const empty = document.createElement("div");
    empty.className = "comboItem";
    empty.setAttribute("role","option");
    empty.setAttribute("aria-selected", value==="" ? "true" : "false");
    empty.innerHTML = `<div class="text">${escapeHtml(placeholder)}</div><div class="mark"></div>`;
    empty.addEventListener("click",()=>{ setValue("", true); setOpen(false); btn.focus(); });
    menu.appendChild(empty);

    for (const it of items){
      const opt = document.createElement("div");
      opt.className = "comboItem";
      opt.setAttribute("role","option");
      opt.setAttribute("aria-selected", it.value===value ? "true" : "false");

      const badge = it.meta?.badgeText
        ? `<span class="tag ${escapeHtml(it.meta.badgeClass||"")}">${escapeHtml(it.meta.badgeText)}</span>`
        : "";

      opt.innerHTML = `<div class="text">${escapeHtml(it.label)}</div><div class="mark">${badge}</div>`;
      opt.addEventListener("click",()=>{ setValue(it.value, true); setOpen(false); btn.focus(); });
      menu.appendChild(opt);
    }
  }

  function paintActive(){
    const children = Array.from(menu.querySelectorAll(".comboItem"));
    children.forEach((el,i)=> el.classList.toggle("active", i===activeIndex));
  }
  function scrollActiveIntoView(){
    const el = menu.querySelectorAll(".comboItem")[activeIndex];
    if (el) el.scrollIntoView({ block:"nearest" });
  }
  function onDocDown(e){ if (!root.contains(e.target)) setOpen(false); }
  function onDocKeyDown(e){
    if (!open && (e.key==="ArrowDown" || e.key==="ArrowUp")){
      e.preventDefault(); setOpen(true); return;
    }
    if (!open) return;

    if (e.key==="Escape"){ e.preventDefault(); setOpen(false); btn.focus(); return; }
    if (e.key==="ArrowDown"){ e.preventDefault(); activeIndex=Math.min((items.length+1)-1, activeIndex+1); paintActive(); scrollActiveIntoView(); return; }
    if (e.key==="ArrowUp"){ e.preventDefault(); activeIndex=Math.max(0, activeIndex-1); paintActive(); scrollActiveIntoView(); return; }
    if (e.key==="Enter"){
      e.preventDefault();
      const allOpts = ["", ...items.map(x=>x.value)];
      const v = allOpts[activeIndex] ?? "";
      setValue(v, true);
      setOpen(false);
      btn.focus();
      return;
    }
    if (e.key==="Home"){ e.preventDefault(); activeIndex=0; paintActive(); scrollActiveIntoView(); return; }
    if (e.key==="End"){ e.preventDefault(); activeIndex=(items.length+1)-1; paintActive(); scrollActiveIntoView(); return; }
  }

  function setOpen(next){
    open = next;
    root.setAttribute("aria-expanded", open ? "true":"false");
    menu.classList.toggle("open", open);
    if (open){
      const allVals = ["", ...items.map(x=>x.value)];
      const idx = allVals.findIndex(v=>v===value);
      activeIndex = idx>=0 ? idx : 0;
      paintActive();
      requestAnimationFrame(scrollActiveIntoView);
      document.addEventListener("mousedown", onDocDown, true);
      document.addEventListener("keydown", onDocKeyDown, true);
    } else {
      document.removeEventListener("mousedown", onDocDown, true);
      document.removeEventListener("keydown", onDocKeyDown, true);
    }
  }

  function setItems(nextItems){
    items = Array.isArray(nextItems) ? nextItems : [];
    if (value && !items.some(x=>x.value===value)) value = "";
    render();
  }
  function setValue(next, fire=false){
    value = next || "";
    render();
    if (fire) root.dispatchEvent(new CustomEvent("change", { detail:{ value } }));
  }
  function getValue(){ return value; }

  function setHighlightClass(cls){
    btn.classList.remove("ideal-selected","active-selected","match-selected");
    if (!cls) return;
    if (cls==="match") btn.classList.add("match-selected");
    else if (cls==="ideal") btn.classList.add("ideal-selected");
    else if (cls==="active") btn.classList.add("active-selected");
  }

  btn.addEventListener("click",()=> setOpen(!open));

  root._combo = { setItems, setValue, getValue, setHighlightClass };
  render();
  return root;
}

// Planner
class Planner {
  constructor(store) { this.store = store; this.selectedKey = null; this.openNodes = new Set(); }
  pickRecipeIdForOutput(outKey) { const fav = favorites.get(outKey); const ids = this.store.outputsFor(outKey); return (fav && ids.includes(fav)) ? fav : null; }
  resolveTag(tagName, outKeyCtx, recipeIdCtx) { return getRecipeTagChoice(outKeyCtx, recipeIdCtx, tagName) || null; }

  build() {
    const nodes = new Map(); const edges = [];
    const demand = (key, qty, parent = null, via = null, pathSet = new Set()) => {
      if (!nodes.has(key)) nodes.set(key, this.createNode(key));
      const node = nodes.get(key);
      node.requested += qty;
      if (parent && via) edges.push({ parentKey: parent, childKey: key, via, requiredQty: qty });

      if (pathSet.has(key)) return;
      const nextPath = new Set(pathSet); nextPath.add(key);

      const availableIds = this.store.outputsFor(key);
      const recipeId = this.pickRecipeIdForOutput(key);
      node.hasOptions = availableIds.length > 0;
      node.isBaseOverride = baseOverrides.has(key);
      node.needsChoice = node.hasOptions && !recipeId && !node.isBaseOverride;
      node.recipeId = node.isBaseOverride ? null : recipeId;

      // Hidden items count as "done" for planning math
      const have = planningHave(key, node.requested);

      let outPerCraft = 1;
      if (node.recipeId) {
        const rec = store.getRecipe(node.recipeId);
        const out = rec.outputs.find(o => (o.key || keyOf(o.item, o.meta || 0)) === key) || rec.outputs[0];
        outPerCraft = Math.max(out?.count || 1, 1);
      }
      node.outPerCraft = outPerCraft;

      const craftsNeededNow = node.recipeId ? Math.max(0, ceilDiv(Math.max(node.requested - have, 0), outPerCraft)) : 0;
      const alreadyPropagated = node.propagatedCrafts || 0;
      node.craftsNeeded = craftsNeededNow;

      if (node.recipeId) {
        const deltaCrafts = Math.max(0, craftsNeededNow - alreadyPropagated);
        if (deltaCrafts > 0) {
          const rec = store.getRecipe(node.recipeId);
          node.machine = rec.machine; node.euPerTick = rec.euPerTick; node.duration = rec.duration;

          for (const ing of rec.inputs) {
            const mult = deltaCrafts * (igCount(ing));
            if (ing.tag) {
              const resolved = this.resolveTag(ing.tag, key, node.recipeId);
              if (!resolved) {
                const tagKey = `tag:${ing.tag}`;
                if (!nodes.has(tagKey)) nodes.set(tagKey, this.createNode(tagKey, { nameOverride: `Tag: ${ing.tag}` }));
                demand(tagKey, mult, key, ing, nextPath);
              } else {
                demand(resolved, mult, key, ing, nextPath);
              }
            } else if (ing.item) {
              const childKey = ing.key || keyOf(ing.item, ing.meta || 0);
              demand(childKey, mult, key, ing, nextPath);
            }
          }
          node.propagatedCrafts = alreadyPropagated + deltaCrafts;
        }
      }
    };

    for (const t of planTargets) demand(t.key, t.qty, null, null, new Set());

    for (const node of nodes.values()) {
      node.have = planningHave(node.key, node.requested);
      node.remaining = Math.max(node.requested - node.have, 0);
      node.isBase = (!store.outputsFor(node.key).length && !node.key.startsWith("tag:")) || node.isBaseOverride;
    }

    const toGather = [];
    for (const node of nodes.values()) {
      const isLeaf = node.key.startsWith("tag:") || node.needsChoice || !node.recipeId;
      if (isLeaf && node.remaining > 0) {
        const name = this.nameOf(node.key);
        if (/programmed\s*circuit/i.test(name)) continue;
        let reason = "base";
        if (node.key.startsWith("tag:")) reason = "unresolved-tag";
        else if (node.needsChoice) reason = "needs-choice";
        else if (!node.hasOptions) reason = "base";
        toGather.push({ key: node.key, qty: node.remaining, name, reason, isBaseOverride: node.isBaseOverride });
      }
    }
    toGather.sort((a, b) => a.name.localeCompare(b.name));
    return { nodes, edges, toGather };
  }

  createNode(key, opts = {}) {
    return {
      key, name: opts.nameOverride || this.nameOf(key),
      requested: 0, have: 0, remaining: 0,
      recipeId: null, outPerCraft: 1, craftsNeeded: 0, propagatedCrafts: 0,
      isBase: false, machine: null, euPerTick: null, duration: null,
      hasOptions: false, needsChoice: false, isBaseOverride: false
    };
  }
  nameOf(key) { if (key.startsWith("tag:")) return `Tag: ${key.slice(4)}`; return store.getItemName(key); }
}
const planner = new Planner(store);

function igCount(ing){ return Math.max(1, ing.count ?? 1); }

function craftsPossibleFor(outKey, recipeId) {
  const r = store.getRecipe(recipeId);
  if (!r) return 0;
  if (!r.inputs || r.inputs.length === 0) return Infinity;

  let possible = Infinity;

  for (const ing of r.inputs) {
    const needPer = igCount(ing);

    if (ing.tag) {
      const tagKey = `tag:${ing.tag}`;
      const choice = getRecipeTagChoice(outKey, recipeId, ing.tag);

      if (!choice) {
        if (gatherHiddenKeys.has(tagKey)) continue;
        return 0;
      }

      const have = planningHave(choice, needPer);
      possible = Math.min(possible, Math.floor(have / needPer));
    } else {
      const k = ing.key || keyOf(ing.item, ing.meta || 0);
      const have = planningHave(k, needPer);
      possible = Math.min(possible, Math.floor(have / needPer));
    }
  }

  return Number.isFinite(possible) ? possible : 0;
}

function recipeUsesKey(r, outKeyCtx, targetKey) {
  if (!r || !targetKey) return false;
  for (const ing of r.inputs || []) {
    if (ing.tag) {
      const tagKey = `tag:${ing.tag}`;
      const resolved = getRecipeTagChoice(outKeyCtx, r.id, ing.tag);
      if (targetKey === tagKey) return true;
      if (resolved && resolved === targetKey) return true;
    } else {
      const k = ing.key || keyOf(ing.item, ing.meta || 0);
      if (k === targetKey) return true;
    }
  }
  return false;
}
function setIngredientFocus(key) { ingredientFocusKey = (ingredientFocusKey === key ? null : key); renderTodo(); }

// Remaining-to-gather hiding helpers
function isMoldName(name){ return /^mold\b/i.test(String(name || "").trim()); }
function isExtruderShapeName(name){ return /^extruder\s*shape\b/i.test(String(name || "").trim()); }

function classifyAutoHiddenKindByName(name){
  if (gatherHideFilters.hideMolds && isMoldName(name)) return "mold";
  if (gatherHideFilters.hideExtruderShapes && isExtruderShapeName(name)) return "extruder";
  return null;
}
function autoHideIfMatches(g){
  const name = g?.name || store.getItemName(g?.key || "");
  const kind = classifyAutoHiddenKindByName(name);
  if (!kind) return false;
  if (!g || !g.key) return false;
  if (gatherHiddenKeys.has(g.key)) return true;
  gatherHiddenKeys.add(g.key);
  persistHiddenNow();
  return true;
}
function isHiddenByGatherFilters(g){
  const name = g?.name || store.getItemName(g?.key || "");
  if (gatherHideFilters.hideMolds && isMoldName(name)) return true;
  if (gatherHideFilters.hideExtruderShapes && isExtruderShapeName(name)) return true;
  return false;
}
function isHiddenInGatherList(g){
  if (isHiddenByGatherFilters(g)) return true;
  return gatherHiddenKeys.has(g.key);
}
function updateHiddenItemsButton(){
  if (!btnHiddenItems) return;
  const n = gatherHiddenKeys.size || 0;
  btnHiddenItems.textContent = `Hidden Items (${n})`;
  btnHiddenItems.disabled = (n === 0);
}
function updateBaseItemsButton(){
  if (!btnBaseItems) return;
  const n = baseOverrides.size || 0;
  btnBaseItems.textContent = `Base Items (${n})`;
  btnBaseItems.disabled = (n === 0);
}

// Rendering
function renderAll() {
  setLeftTab(leftTab);
  updateCollapseUI();
  applyColumnSizes();
  renderInspector();
  renderPlan();
}
function renderLeftPane() { leftTab === "catalog" ? renderCatalog() : renderFavoritesTab(); }

// Catalog
function renderCatalog() {
  const q = (searchBox.value || "").trim().toLowerCase();
  const keys = Array.from(store.byOutput.keys());
  const results = keys.filter(k => {
    const name = store.getItemName(k).toLowerCase();
    const metaId = String(store.getMetaId(k) ?? "");
    return !q || name.includes(q) || k.toLowerCase().includes(q) || metaId.includes(q);
  }).sort((a, b) => store.getItemName(a).localeCompare(store.getItemName(b)));
  catalogList.innerHTML = "";
  for (const key of results.slice(0, 1000)) catalogList.appendChild(catalogItemRow(key));
  if (!results.length) catalogList.innerHTML = `<li><span class="muted">No items match your search.</span></li>`;
}
function catalogItemRow(key) {
  const li = document.createElement("li");
  const left = document.createElement("div"); left.className = "row"; left.appendChild(itemPill(store.getItemName(key), key)); li.appendChild(left);

  const right = document.createElement("div"); right.className = "row";
  const hasRecipes = store.outputsFor(key).length > 0;

  if (hasRecipes) {
    const { activeId, idealId, match } = favPairFor(key);

    const favBtn = document.createElement("button");
    favBtn.className = "icon starbtn";
    applyStarBtnClass(favBtn, "active", match);
    favBtn.title = activeId ? "ACTIVE recipe selected (used in planning)" : "Select ACTIVE recipe (used in planning)";
    favBtn.textContent = activeId ? "★" : "☆";
    favBtn.addEventListener("click", (e) => { e.stopPropagation(); pickFavoriteViaDialog(key, { mode: "active" }); });

    const idealBtn = document.createElement("button");
    idealBtn.className = "icon starbtn";
    applyStarBtnClass(idealBtn, "ideal", match);
    idealBtn.title = idealId ? "IDEAL recipe bookmarked" : "Select IDEAL recipe (bookmark only)";
    idealBtn.textContent = idealId ? "★" : "☆";
    idealBtn.addEventListener("click", (e) => { e.stopPropagation(); pickFavoriteViaDialog(key, { mode: "ideal" }); });

    right.appendChild(favBtn);
    right.appendChild(idealBtn);
  }

  li.appendChild(right);
  li.addEventListener("click", () => focusInspectorOnKey(key));
  return li;
}

// Favorites tab helpers
function recipeUsesIngredientText(outKey, recId, needleLower) {
  const r = store.getRecipe(recId); if (!r) return false;
  const names = [];
  for (const ing of r.inputs || []) {
    if (ing.tag) { const chosen = getRecipeTagChoice(outKey, recId, ing.tag); names.push(chosen ? store.getItemName(chosen) : `Tag: ${ing.tag}`); }
    else { const k = ing.key || keyOf(ing.item, ing.meta || 0); names.push(store.getItemName(k)); }
  }
  if (Array.isArray(r.circuits) && r.circuits.length) for (const n of r.circuits) names.push(`Programmed Circuit #${n}`);
  return names.some(n => n.toLowerCase().includes(needleLower));
}
function renderFavoritesTab() {
  favoritesList.innerHTML = "";
  updateFavFilterButtons();

  const keys = new Set([...favorites.keys(), ...favoritesIdeal.keys()]);
  const qOut = (favSearchOutput?.value || "").trim().toLowerCase();
  const qIng = (favSearchIngredient?.value || "").trim().toLowerCase();

  const rows = Array.from(keys).map(outKey => {
    const p = favPairFor(outKey);
    return { outKey, ...p };
  }).filter(row => {
    const validActive = row.activeId && store.outputsFor(row.outKey).includes(row.activeId);
    const validIdeal = row.idealId && store.outputsFor(row.outKey).includes(row.idealId);
    if (!validActive && !validIdeal) return false;

    if (favoritesFilter === "match" && !row.match) return false;
    if (favoritesFilter === "blue" && !row.blue) return false;
    if (favoritesFilter === "missing" && !row.missing) return false;

    const outName = store.getItemName(row.outKey).toLowerCase();
    if (qOut && !outName.includes(qOut) && !row.outKey.toLowerCase().includes(qOut)) return false;

    if (qIng) {
      const aOk = validActive ? recipeUsesIngredientText(row.outKey, row.activeId, qIng) : false;
      const iOk = validIdeal ? recipeUsesIngredientText(row.outKey, row.idealId, qIng) : false;
      if (!aOk && !iOk) return false;
    }
    return true;
  }).sort((a, b) => store.getItemName(a.outKey).localeCompare(store.getItemName(b.outKey)));

  if (!rows.length) { favoritesList.innerHTML = `<li><span class="muted">No favorites match your current filters/search.</span></li>`; return; }

  for (const row of rows) {
    const li = document.createElement("li");
    const left = document.createElement("div"); left.className = "row";
    left.appendChild(itemPill(store.getItemName(row.outKey), row.outKey));

    const machineCls = machineTagClassForOutKey(row.outKey);

    if (row.activeId) {
      const r = store.getRecipe(row.activeId);
      if (r) left.appendChild(tagEl(`Active: ${prettyMachine(r)}`, machineCls));
    }
    if (row.idealId) {
      const r = store.getRecipe(row.idealId);
      if (r) left.appendChild(tagEl(`Ideal: ${prettyMachine(r)}`, machineCls));
    }

    const right = document.createElement("div"); right.className = "row";
    const go = document.createElement("button"); go.className = "icon"; go.textContent = "Go"; go.addEventListener("click", () => focusInspectorOnKey(row.outKey));

    const setActive = document.createElement("button");
    setActive.className = "icon starbtn";
    applyStarBtnClass(setActive, "active", row.match);
    setActive.textContent = row.activeId ? "★" : "☆";
    setActive.title = "Edit ACTIVE favorite";
    setActive.addEventListener("click", (e) => { e.stopPropagation(); pickFavoriteViaDialog(row.outKey, { mode: "active" }); });

    const setIdeal = document.createElement("button");
    setIdeal.className = "icon starbtn";
    applyStarBtnClass(setIdeal, "ideal", row.match);
    setIdeal.textContent = row.idealId ? "★" : "☆";
    setIdeal.title = "Edit IDEAL favorite";
    setIdeal.addEventListener("click", (e) => { e.stopPropagation(); pickFavoriteViaDialog(row.outKey, { mode: "ideal" }); });

    const clr = document.createElement("button"); clr.className = "icon"; clr.textContent = "✕"; clr.title = "Clear both Active + Ideal";
    clr.addEventListener("click", () => {
      favorites.delete(row.outKey);
      favoritesIdeal.delete(row.outKey);
      persistAll(); renderAll(); setLeftTab("favorites");
    });

    right.append(go, setActive, setIdeal, clr);
    li.append(left, right);
    favoritesList.appendChild(li);
  }
}

// Inspector (unchanged)
function renderInspector() {
  const outKey = planner.selectedKey;
  inspectorTitle.textContent = outKey ? "— " + store.getItemName(outKey) : "";
  recipeArea.innerHTML = "";
  if (!outKey) { renderTodo(); return; }

  const recipeIds = store.outputsFor(outKey);
  const baseMarked = baseOverrides.has(outKey);

  const header = document.createElement("div"); header.className = "row"; header.style.flexWrap = "wrap"; header.style.gap = "8px";
  const typeSelect = document.createElement("select"); typeSelect.style.minWidth = "200px";

  const recipeCombo = createRecipeComboBox({ placeholder: "— Select a recipe —" });
  const comboApi = recipeCombo._combo;

  const search = document.createElement("input"); search.type = "search"; search.placeholder = "Search recipes (inputs/machine)…"; search.style.minWidth = "260px";

  const { activeId: currentFav, idealId: currentIdeal, match } = favPairFor(outKey);
  const groups = groupRecipesByType(recipeIds);

  function groupOfRecipeId(id) {
    const r = id ? store.getRecipe(id) : null;
    return r ? groupLabelForRecipe(r) : "";
  }

  function refreshTypeOptions() {
    typeSelect.innerHTML = "";
    const opt0 = document.createElement("option"); opt0.value = ""; opt0.textContent = "— Choose type —"; typeSelect.appendChild(opt0);

    const idealGroup = groupOfRecipeId(currentIdeal);
    const activeGroup = groupOfRecipeId(currentFav);

    for (const g of Object.keys(groups).sort()) {
      const opt = document.createElement("option");
      opt.value = g;
      const marks = [];
      if (g === activeGroup) marks.push(match ? "MATCH" : "ACTIVE");
      if (g === idealGroup) marks.push(match ? "MATCH" : "IDEAL");
      opt.textContent = marks.length ? `${g} (${marks.join(", ")})` : g;
      typeSelect.appendChild(opt);
    }

    if (idealGroup && [...typeSelect.options].some(o=>o.value===idealGroup)) typeSelect.value = idealGroup;
    else if (activeGroup && [...typeSelect.options].some(o=>o.value===activeGroup)) typeSelect.value = activeGroup;
    else typeSelect.value = "";
  }

  function recipeLabelFor(id) {
    const r = store.getRecipe(id);
    const out = r.outputs.find(o => (o.key || keyOf(o.item, o.meta || 0)) === outKey) || r.outputs[0];
    const circ = Array.isArray(r.circuits) && r.circuits.length ? ` • Circuit #${r.circuits.join(",")}` : "";
    const isA = !!(currentFav && id === currentFav);
    const isI = !!(currentIdeal && id === currentIdeal);
    const markA = isA ? (match ? " • MATCH★" : " • ACTIVE★") : "";
    const markI = isI ? (match ? " • MATCH★" : " • IDEAL★") : "";
    return `${prettyMachine(r)} • yields ${out.count} • ${summInputs(r)}${circ}${markA}${markI}`;
  }

  function updateDropdownHighlights() {
    const idealGroup = groupOfRecipeId(currentIdeal);
    const activeGroup = groupOfRecipeId(currentFav);

    if (match && typeSelect.value && (typeSelect.value === idealGroup || typeSelect.value === activeGroup)) applySelectHighlight(typeSelect, "match");
    else if (typeSelect.value && typeSelect.value === idealGroup) applySelectHighlight(typeSelect, "ideal");
    else if (typeSelect.value && typeSelect.value === activeGroup) applySelectHighlight(typeSelect, "active");
    else applySelectHighlight(typeSelect, null);

    const sel = comboApi.getValue() || "";
    if (match && sel && currentFav && sel === currentFav) comboApi.setHighlightClass("match");
    else if (sel && currentIdeal && sel === currentIdeal) comboApi.setHighlightClass("ideal");
    else if (sel && currentFav && sel === currentFav) comboApi.setHighlightClass("active");
    else comboApi.setHighlightClass(null);
  }

  function refreshRecipeOptions() {
    const g = typeSelect.value;
    const q = (search.value || "").toLowerCase();

    const ids = g ? (groups[g] || []) : [];
    const items = [];

    for (const id of ids) {
      const label = recipeLabelFor(id);
      if (q && !label.toLowerCase().includes(q)) continue;

      const isA = !!(currentFav && id === currentFav);
      const isI = !!(currentIdeal && id === currentIdeal);
      const isM = match && isA && isI;

      let badgeText = "", badgeClass = "";
      if (isM) { badgeText = "MATCH"; badgeClass = "match"; }
      else if (isA) { badgeText = "ACTIVE"; badgeClass = "active"; }
      else if (isI) { badgeText = "IDEAL"; badgeClass = "ideal"; }

      items.push({ value: id, label, meta: badgeText ? { badgeText, badgeClass } : null });
    }

    comboApi.setItems(items);

    if (currentIdeal && ids.includes(currentIdeal)) comboApi.setValue(currentIdeal);
    else if (currentFav && ids.includes(currentFav)) comboApi.setValue(currentFav);
    else comboApi.setValue("");

    updateDropdownHighlights();
  }

  refreshTypeOptions();
  refreshRecipeOptions();

  typeSelect.addEventListener("change", () => { refreshRecipeOptions(); renderRecipeDetails(); });
  search.addEventListener("input", () => { refreshRecipeOptions(); renderRecipeDetails(); });
  recipeCombo.addEventListener("change", () => { updateDropdownHighlights(); renderRecipeDetails(); });

  const favBtn = document.createElement("button");
  favBtn.className = "icon starbtn";
  applyStarBtnClass(favBtn, "active", match);
  favBtn.textContent = match ? "Match ★" : "Active ★";
  favBtn.title = "Save selected recipe as ACTIVE (used in planning)";
  favBtn.addEventListener("click", () => {
    const val = comboApi.getValue(); if (!val) { alert("Pick a recipe first."); return; }
    favorites.set(outKey, val); persistAll(); renderAll(); toast("ACTIVE recipe saved");
  });

  const idealBtn = document.createElement("button");
  idealBtn.className = "icon starbtn";
  applyStarBtnClass(idealBtn, "ideal", match);
  idealBtn.textContent = match ? "Match ★" : "Ideal ★";
  idealBtn.title = "Save selected recipe as IDEAL (bookmark only)";
  idealBtn.addEventListener("click", () => {
    const val = comboApi.getValue(); if (!val) { alert("Pick a recipe first."); return; }
    favoritesIdeal.set(outKey, val); persistAll(); renderAll(); toast("IDEAL recipe saved");
  });

  const jumpIdeal = document.createElement("button");
  jumpIdeal.className = "ghost";
  jumpIdeal.textContent = "Jump to ideal";
  jumpIdeal.disabled = !currentIdeal;
  jumpIdeal.title = "Select the ideal machine type and recipe in the dropdowns";
  jumpIdeal.addEventListener("click", () => {
    if (!currentIdeal) return;
    const g = groupOfRecipeId(currentIdeal);
    if (g && groups[g]) typeSelect.value = g;
    refreshRecipeOptions();
    comboApi.setValue(currentIdeal, true);
    updateDropdownHighlights();
    renderRecipeDetails();
  });

  const jumpActive = document.createElement("button");
  jumpActive.className = "ghost";
  jumpActive.textContent = "Jump to active";
  jumpActive.disabled = !currentFav;
  jumpActive.title = "Select the active machine type and recipe in the dropdowns";
  jumpActive.addEventListener("click", () => {
    if (!currentFav) return;
    const g = groupOfRecipeId(currentFav);
    if (g && groups[g]) typeSelect.value = g;
    refreshRecipeOptions();
    comboApi.setValue(currentFav, true);
    updateDropdownHighlights();
    renderRecipeDetails();
  });

  const qty = document.createElement("input"); qty.type = "number"; qty.min = "1"; qty.step = "1"; qty.value = "1"; qty.title = "Target quantity";
  const addBtn = document.createElement("button"); addBtn.className = "primary"; addBtn.textContent = "Add to plan";
  addBtn.addEventListener("click", () => {
    const qn = Math.max(1, Math.floor(Number(qty.value) || 1));
    const found = planTargets.find(t => t.key === outKey);
    if (found) found.qty += qn; else planTargets.push({ key: outKey, qty: qn });
    persistAll(); renderAll(); toast("Added to plan");
  });

  const baseBtn = document.createElement("button"); baseBtn.className = "ghost"; baseBtn.textContent = baseMarked ? "Unmark base" : "Mark as base";
  baseBtn.title = "Treat this as a base ingredient (won’t require a recipe)";
  baseBtn.addEventListener("click", () => { if (baseOverrides.has(outKey)) baseOverrides.delete(outKey); else baseOverrides.add(outKey); persistAll(); renderAll(); });

  header.append(typeSelect, recipeCombo, search, favBtn, idealBtn, jumpIdeal, jumpActive, qty, addBtn, baseBtn);
  recipeArea.append(header);

  const details = document.createElement("div");
  details.id = "recipeDetails";
  details.style.marginTop = "8px";
  recipeArea.append(details);

  renderRecipeDetails();
  renderTodo();

  function renderRecipeDetails() {
    const selectedId =
      comboApi.getValue() ||
      currentIdeal ||
      currentFav ||
      ((groups[typeSelect.value] || [])[0] || recipeIds[0] || "");

    const r = selectedId ? store.getRecipe(selectedId) : null;
    details.innerHTML = "";
    if (!r) return;

    const outForSelected = r.outputs.find(o => (o.key || keyOf(o.item, o.meta || 0)) === outKey) || r.outputs[0];
    const outPerCraft = Math.max(outForSelected?.count || 1, 1);
    const currentNodeCrafts = craftsNeededForSelected(outKey, selectedId, outPerCraft);

    const head = document.createElement("div");
    const circBadge = Array.isArray(r.circuits) && r.circuits.length ? ` • <span class="tag">Circuit #${r.circuits.join(",")}</span>` : "";

    const isA = !!(currentFav && selectedId === currentFav);
    const isI = !!(currentIdeal && selectedId === currentIdeal);
    const isM = match && isA && isI;

    const activeBadge = isA ? ` • <span class="tag ${isM ? "match" : "active"}">${isM ? "MATCH" : "ACTIVE"}</span>` : "";
    const idealBadge  = isI ? ` • <span class="tag ${isM ? "match" : "ideal"}">${isM ? "MATCH" : "IDEAL"}</span>` : "";

    const machineCls = machineTagClassForOutKey(outKey);

    head.innerHTML =
      `<span class="tag ${machineCls}">${prettyMachine(r)}</span> ` +
      `• yields <span class="mono">${fmtQty(outPerCraft, outKey)}</span> per craft` +
      `${circBadge}${activeBadge}${idealBadge}`;
    details.appendChild(head);

    const h1 = document.createElement("div"); h1.style.marginTop = "8px"; h1.innerHTML = "<strong>Resource cost (for this step)</strong>";
    details.appendChild(h1);

    const combinedInputs = combineInputsForDisplay(r.inputs, outKey, r.id).map(e => ({ ...e, qty: e.qty * currentNodeCrafts }));
    const ulCost = document.createElement("ul"); ulCost.className = "list";
    for (const entry of combinedInputs) {
      const li = document.createElement("li");
      const left = document.createElement("div"); left.className = "row";
      left.appendChild(span(`${fmtQty(entry.qty, entry.keyForFmt)}× ${entry.label}`, ""));
      if (entry.using) left.appendChild(tagEl(`using ${entry.using}`));
      li.appendChild(left);
      ulCost.appendChild(li);
    }
    if (!combinedInputs.length) {
      const li = document.createElement("li"); li.appendChild(span("<span class='muted'>No inputs</span>", "")); ulCost.appendChild(li);
    }
    details.appendChild(ulCost);

    const footBar = document.createElement("div");
    footBar.className = "row";
    footBar.style.margin = "6px 0";
    if (Array.isArray(r.circuits) && r.circuits.length) footBar.appendChild(tagEl(`Circuit #${r.circuits.join(",")}`));
    const built = planner.build();
    const node = built.nodes.get(outKey);
    const needNow = Math.max(0, node?.remaining || 0);
    const markDone = document.createElement("button");
    markDone.className = "primary";
    markDone.textContent = "Mark done";
    markDone.title = `Add ${needNow} obtained for ${store.getItemName(outKey)}`;
    markDone.addEventListener("click", () => { bumpObtained(outKey, needNow); });
    footBar.appendChild(markDone);
    details.appendChild(footBar);

    const h2 = document.createElement("div"); h2.style.marginTop = "8px"; h2.innerHTML = "<strong>Outputs (total for this step)</strong>";
    details.appendChild(h2);

    const ulOut = document.createElement("ul"); ulOut.className = "list";
    for (const o of r.outputs) {
      const li = document.createElement("li");
      const k = o.key || keyOf(o.item, o.meta || 0);
      const total = Math.max(1, o.count || 1) * currentNodeCrafts;
      li.appendChild(span(`${fmtQty(total, k)}× ${store.getItemName(k)}`, ""));
      ulOut.appendChild(li);
    }
    details.appendChild(ulOut);

    const tagInputs = (r.inputs || []).filter(x => !!x.tag);
    if (tagInputs.length) {
      const combinedTags = combineTagInputsForDisplay(tagInputs).map(t => ({ ...t, qty: t.qty * currentNodeCrafts }));
      const h3 = document.createElement("div"); h3.style.marginTop = "8px"; h3.innerHTML = "<strong>Choose items for tags</strong> <span class='muted'>(applies to this recipe only)</span>";
      details.appendChild(h3);

      const list = document.createElement("ul"); list.className = "list";
      for (const t of combinedTags) {
        const li = document.createElement("li");
        const left = document.createElement("div"); left.className = "row";
        left.appendChild(span(`${fmtQty(t.qty)}× Tag: ${t.tag}`, ""));
        const current = getRecipeTagChoice(outKey, r.id, t.tag);
        if (current) left.appendChild(tagEl(`using ${store.getItemName(current)}`));
        li.appendChild(left);

        const right = document.createElement("div"); right.className = "row";
        const choose = document.createElement("button"); choose.className = "icon"; choose.textContent = "Choose…";
        choose.addEventListener("click", () => openTagChooserModal(t.tag, outKey, r.id));
        const clear = document.createElement("button"); clear.className = "icon"; clear.textContent = "Clear";
        clear.addEventListener("click", () => { setRecipeTagChoice(outKey, r.id, t.tag, null); renderInspector(); });
        right.append(choose, clear);
        li.appendChild(right);

        list.appendChild(li);
      }
      details.appendChild(list);
    }
  }
}

function craftsNeededForSelected(outKey, recipeId) {
  const built = planner.build();
  const node = built.nodes.get(outKey);
  if (node && node.recipeId === recipeId) return Math.max(1, node.craftsNeeded || 1);
  return 1;
}

// Combine helpers
function combineInputsForDisplay(inputs, outKeyCtx, recipeId) {
  const map = new Map();
  for (const ing of inputs) {
    let label, using, keyForFmt = null;
    if (ing.tag) {
      label = `Tag: ${ing.tag}`;
      const chosen = getRecipeTagChoice(outKeyCtx, recipeId, ing.tag);
      using = chosen ? store.getItemName(chosen) : null;
      keyForFmt = null;
    } else {
      const k = ing.key || keyOf(ing.item, ing.meta || 0);
      keyForFmt = k;
      label = store.getItemName(k);
    }
    const qty = igCount(ing);
    const key = label;
    if (!map.has(key)) map.set(key, { qty: 0, label, using: using || null, keyForFmt });
    const obj = map.get(key);
    obj.qty += qty;
    if (using) obj.using = using;
  }
  return Array.from(map.values());
}
function combineTagInputsForDisplay(tagInputs) {
  const map = new Map();
  for (const ing of tagInputs) {
    const tag = ing.tag;
    const qty = igCount(ing);
    if (!map.has(tag)) map.set(tag, { tag, qty: 0 });
    map.get(tag).qty += qty;
  }
  return Array.from(map.values());
}

// Modal tag chooser
const modalBackdrop = document.getElementById("modalBackdrop");
const modTitle = document.getElementById("modTitle");
const modBody = document.getElementById("modBody");
const modFoot = document.getElementById("modFoot");
document.getElementById("modClose").addEventListener("click", closeModal);
modalBackdrop.addEventListener("click", (e) => { if (e.target === modalBackdrop) closeModal(); });

function openModal(title, buildBody, buildFoot) {
  modTitle.textContent = title;
  modBody.innerHTML = "";
  modFoot.innerHTML = "";
  buildBody?.(modBody);
  buildFoot?.(modFoot);
  modalBackdrop.style.display = "flex";
}
function closeModal() { modalBackdrop.style.display = "none"; }

function openTagChooserModal(tagName, outKeyCtx, recipeId) {
  const candidates = store.tags.get(tagName) || [];
  openModal(`Choose item for tag: ${tagName}`, (body) => {
    const search = document.createElement("input");
    search.type = "search";
    search.placeholder = "Search candidates in this tag...";
    body.appendChild(search);

    const list = document.createElement("div"); list.style.display = "flex"; list.style.flexDirection = "column"; list.style.gap = "6px"; list.style.marginTop = "6px";
    body.appendChild(list);

    const current = getRecipeTagChoice(outKeyCtx, recipeId, tagName);

    function render() {
      list.innerHTML = "";
      const q = (search.value || "").toLowerCase();
      for (const k of candidates) {
        const name = store.getItemName(k);
        if (q && !name.toLowerCase().includes(q) && !k.toLowerCase().includes(q)) continue;
        const row = document.createElement("div"); row.className = "row space"; row.style.borderBottom = "1px dashed #21262d"; row.style.padding = "6px 4px";
        const left = document.createElement("div"); left.className = "row";
        left.appendChild(itemPill(name, k));
        if (current === k) left.appendChild(tagEl("current"));
        const right = document.createElement("div");
        const use = document.createElement("button"); use.className = "icon"; use.textContent = "Use";
        use.addEventListener("click", () => { setRecipeTagChoice(outKeyCtx, recipeId, tagName, k); closeModal(); renderInspector(); });
        right.appendChild(use);
        row.append(left, right); list.appendChild(row);
      }
    }
    search.addEventListener("input", render);
    render();
  }, (foot) => {
    const clear = document.createElement("button"); clear.className = "ghost"; clear.textContent = "Clear choice";
    clear.addEventListener("click", () => { setRecipeTagChoice(outKeyCtx, recipeId, tagName, null); closeModal(); renderInspector(); });
    const close = document.createElement("button"); close.className = "icon"; close.textContent = "Close";
    close.addEventListener("click", closeModal);
    foot.append(clear, close);
  });
}

/**
 * FIX: Hidden Items modal "Mark done" previously used node.remaining, which is 0 because
 * hidden items are treated as satisfied in planningHave(). So the button was disabled.
 *
 * New behavior:
 * - compute "needRaw" ignoring hidden-as-done: max(requested - obtained, 0)
 * - clicking Mark done adds that amount to Owned so it stays satisfied even if unhidden later
 * - this effectively "marks done" for Remaining-to-gather too (it won't come back after unhide)
 */
function openHiddenItemsModal(){
  const keys = Array.from(gatherHiddenKeys);
  keys.sort((a,b) => store.getItemName(a).localeCompare(store.getItemName(b)));

  const built = planner.build();
  const nodes = built.nodes;

  openModal("Hidden Items", (body) => {
    if (!keys.length) {
      body.appendChild(p("<span class='muted'>No hidden items.</span>"));
      return;
    }

    const hint = document.createElement("div");
    hint.className = "muted";
    hint.style.fontSize = "12px";
    hint.textContent = "These are permanently hidden. “Mark done” will add Owned for the amount currently needed by the plan (ignoring hidden-as-done), so it stays done even if you unhide it later.";
    body.appendChild(hint);

    const ul = document.createElement("ul");
    ul.className = "list";
    ul.style.marginTop = "6px";

    for (const k of keys) {
      const li = document.createElement("li");

      const left = document.createElement("div");
      left.className = "row";
      left.appendChild(itemPill(store.getItemName(k), k));

      const node = nodes?.get(k);
      const requested = Math.max(0, node?.requested || 0);
      const haveReal = obtainedNumber(k);
      const needRaw = Math.max(0, requested - haveReal);

      if (requested > 0 && !k.startsWith("tag:")) {
        left.appendChild(tagEl(`need ${fmtQty(needRaw, k)}`, needRaw > 0 ? "warn" : ""));
      } else if (requested <= 0) {
        left.appendChild(tagEl("not in current plan", ""));
      }

      const right = document.createElement("div");
      right.className = "row";

      const markBtn = document.createElement("button");
      markBtn.className = "primary";
      markBtn.textContent = "Mark done";
      markBtn.disabled = (k.startsWith("tag:") || needRaw <= 0);
      markBtn.title = k.startsWith("tag:")
        ? "Tags can’t be marked as obtained automatically"
        : (needRaw > 0 ? `Add ${needRaw} obtained` : "Nothing needed right now");
      markBtn.addEventListener("click", () => {
        if (k.startsWith("tag:")) return;
        if (needRaw <= 0) return;
        bumpObtained(k, needRaw);           // updates Owned and rerenders plan
        // keep modal open and updated
        closeModal();
        openHiddenItemsModal();
      });

      const unhide = document.createElement("button");
      unhide.className = "icon";
      unhide.textContent = "Unhide";
      unhide.addEventListener("click", () => {
        setGatherHiddenFlag(k, false);
        closeModal();
        renderPlan();
        openHiddenItemsModal();
      });

      right.append(markBtn, unhide);
      li.append(left, right);
      ul.appendChild(li);
    }

    body.appendChild(ul);
  }, (foot) => {
    const unhideAll = document.createElement("button");
    unhideAll.className = "ghost";
    unhideAll.textContent = "Unhide all";
    unhideAll.disabled = gatherHiddenKeys.size === 0;
    unhideAll.addEventListener("click", () => {
      gatherHiddenKeys.clear();
      persistHiddenNow();
      updateHiddenItemsButton();
      closeModal();
      renderPlan();
    });

    const close = document.createElement("button");
    close.className = "icon";
    close.textContent = "Close";
    close.addEventListener("click", closeModal);

    foot.append(unhideAll, close);
  });
}
btnHiddenItems?.addEventListener("click", () => {
  if (!gatherHiddenKeys.size) return;
  openHiddenItemsModal();
});

// NEW: Base Items modal
function openBaseItemsModal(){
  const keys = Array.from(baseOverrides);
  keys.sort((a,b) => store.getItemName(a).localeCompare(store.getItemName(b)));

  openModal("Base Items", (body) => {
    if (!keys.length) {
      body.appendChild(p("<span class='muted'>No base items.</span>"));
      return;
    }

    const hint = document.createElement("div");
    hint.className = "muted";
    hint.style.fontSize = "12px";
    hint.textContent = "These items are marked as base (treated as not requiring a recipe). Remove to revert them back to normal planning behavior.";
    body.appendChild(hint);

    const ul = document.createElement("ul");
    ul.className = "list";
    ul.style.marginTop = "6px";

    for (const k of keys) {
      const li = document.createElement("li");

      const left = document.createElement("div");
      left.className = "row";
      left.appendChild(itemPill(store.getItemName(k), k));

      const right = document.createElement("div");
      right.className = "row";

      const remove = document.createElement("button");
      remove.className = "icon";
      remove.textContent = "Remove";
      remove.title = "Remove base status";
      remove.addEventListener("click", () => {
        baseOverrides.delete(k);
        persistAll();
        updateBaseItemsButton();
        closeModal();
        renderAll();
        openBaseItemsModal();
      });

      right.appendChild(remove);
      li.append(left, right);
      ul.appendChild(li);
    }

    body.appendChild(ul);
  }, (foot) => {
    const clearAll = document.createElement("button");
    clearAll.className = "ghost";
    clearAll.textContent = "Clear all";
    clearAll.disabled = baseOverrides.size === 0;
    clearAll.addEventListener("click", () => {
      if (!confirm("Remove base status from all items?")) return;
      baseOverrides.clear();
      persistAll();
      updateBaseItemsButton();
      closeModal();
      renderAll();
    });

    const close = document.createElement("button");
    close.className = "icon";
    close.textContent = "Close";
    close.addEventListener("click", closeModal);

    foot.append(clearAll, close);
  });
}
btnBaseItems?.addEventListener("click", () => {
  if (!baseOverrides.size) return;
  openBaseItemsModal();
});

// Grouping helpers
function groupLabelForRecipe(r) { return r.type === "gregtech" ? (r.machine || "gregtech") : (r.type || "crafting"); }
function groupRecipesByType(recipeIds) { const groups = {}; for (const id of recipeIds) { const r = store.getRecipe(id); const label = groupLabelForRecipe(r); if (!groups[label]) groups[label] = []; groups[label].push(id); } return groups; }
function prettyMachine(r) { const t = (r.machine || r.type || "crafting").toString(); return t.includes(":") ? t.split(":")[1] : t; }
function summInputs(r) { return (r.inputs || []).map(ingredientLabel).join(" + "); }
function ingredientLabel(ing) {
  const qty = igCount(ing);
  if (ing.tag) return `${qty}× <em>${ing.tag}</em>`;
  const key = ing.key || keyOf(ing.item, ing.meta || 0);
  const name = store.getItemName(key);
  if (ing.unit === "mB" || (ing.item || "").startsWith("fluid:")) return `${fmtQty(qty)} mB ${name.replace(/^fluid:/, "")}`;
  return `${fmtQty(qty, key)}× ${name}`;
}

// Regex helpers
function buildRegexEntry(name, idNum) {
  const safeName = String(name)
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\(/g, '\\(')
    .replace(/\)/g, '\\)');
  return `"^${safeName}$" ${idNum ?? 0}`;
}
function compactJoin(entries) { return entries.join("|"); }

// Plan + To‑do
function renderPlan() {
  updateHiddenItemsButton();
  updateBaseItemsButton();

  const { nodes, edges, toGather } = planner.build();

  targetsArea.innerHTML = "<div><strong>Targets</strong></div>";
  if (!planTargets.length) targetsArea.appendChild(p("<span class='muted'>No targets. Select an item and click “Add to plan”.</span>"));
  else {
    for (const t of planTargets) {
      const row = document.createElement("div"); row.className = "row space";
      const left = document.createElement("div"); left.appendChild(itemPill(store.getItemName(t.key), t.key));
      const right = document.createElement("div");
      const input = document.createElement("input"); input.type = "number"; input.min = "1"; input.step = "1"; input.value = t.qty;
      input.addEventListener("change", () => { t.qty = Math.max(1, Math.floor(Number(input.value) || 1)); persistAll(); renderPlan(); });
      const del = document.createElement("button"); del.className = "icon"; del.title = "Remove"; del.textContent = "✕";
      del.addEventListener("click", () => { planTargets = planTargets.filter(x => x !== t); persistAll(); renderAll(); });
      right.append(input, del); row.append(left, right); targetsArea.appendChild(row);
    }
  }

  for (const g of (toGather || [])) autoHideIfMatches(g);

  const visibleGather = (toGather || []).filter(g => !isHiddenInGatherList(g));

  {
    const head = document.createElement("div");
    head.innerHTML = `<strong>Remaining to gather</strong> <span class="muted">(base items, unresolved tags, or items that need a recipe)</span>`;

    const btn = document.createElement("button");
    btn.className = "icon";
    btn.textContent = "Copy Regex";
    btn.style.marginLeft = "8px";
    btn.title = "Copy a compact Regex list of everything visible in Remaining to gather";
    btn.addEventListener("click", () => {
      const list = (visibleGather || []).slice().sort((a, b) => a.name.localeCompare(b.name));
      const parts = [];
      for (const g of list) {
        if (g.key.startsWith("tag:") || g.key.startsWith("fluid:")) continue;
        if (checkedStorage.has(g.key)) continue;
        const idNum = store.getMetaId(g.key);
        parts.push(buildRegexEntry(g.name, idNum));
      }
      const text = compactJoin(parts);
      if (!text) { toast("Nothing to copy"); return; }
      copyText(text);
    });

    const wrapTop = document.createElement("div");
    wrapTop.className = "row";
    wrapTop.style.alignItems = "center";
    wrapTop.appendChild(head);
    wrapTop.appendChild(btn);

    const filtersRow = document.createElement("div");
    filtersRow.className = "gatherFilters";

    const chkMoldsLbl = document.createElement("label");
    const chkMolds = document.createElement("input");
    chkMolds.type = "checkbox";
    chkMolds.checked = !!gatherHideFilters.hideMolds;
    chkMolds.addEventListener("change", () => {
      gatherHideFilters.hideMolds = chkMolds.checked;
      persistGatherFiltersNow();
      renderPlan();
    });
    chkMoldsLbl.append(chkMolds, document.createTextNode("Hide molds (also add to Hidden Items)"));

    const chkExtrLbl = document.createElement("label");
    const chkExtr = document.createElement("input");
    chkExtr.type = "checkbox";
    chkExtr.checked = !!gatherHideFilters.hideExtruderShapes;
    chkExtr.addEventListener("change", () => {
      gatherHideFilters.hideExtruderShapes = chkExtr.checked;
      persistGatherFiltersNow();
      renderPlan();
    });
    chkExtrLbl.append(chkExtr, document.createTextNode("Hide extruder shapes (also add to Hidden Items)"));

    const chkStacksLbl = document.createElement("label");
    const chkStacks = document.createElement("input");
    chkStacks.type = "checkbox";
    chkStacks.checked = !!qtyAsStacks;
    chkStacks.addEventListener("change", () => setQtyAsStacksEnabled(chkStacks.checked));
    chkStacksLbl.append(chkStacks, document.createTextNode("Show item qty as stacks of 64"));

    filtersRow.append(chkMoldsLbl, chkExtrLbl, chkStacksLbl);

    gatherSummary.innerHTML = "";
    gatherSummary.appendChild(wrapTop);
    gatherSummary.appendChild(filtersRow);
  }

  if (!visibleGather.length) {
    gatherSummary.appendChild(p("<span class='accent'>Nothing left to gather.</span>"));
  } else {
    const ul = document.createElement("ul"); ul.className = "list";
    for (const g of visibleGather) {
      const li = document.createElement("li");

      const left = document.createElement("div"); left.className = "row";
      const pill = itemPill(g.name, g.key);
      pill.style.cursor = "pointer";
      pill.title = "Click to highlight steps that use this ingredient";
      pill.addEventListener("click", () => setIngredientFocus(g.key));
      left.appendChild(pill);
      if (g.reason === "needs-choice" && !g.isBaseOverride) left.appendChild(tagEl("needs recipe", "warn"));
      if (g.reason === "unresolved-tag") left.appendChild(tagEl("unresolved tag", "warn"));

      const copyBtn = document.createElement("button"); copyBtn.className = "icon"; copyBtn.textContent = "Copy";
      copyBtn.title = `Copy “${g.name}”`;
      copyBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        if (checkedStorage.has(g.key)) { toast("Item is checked in storage; skipped"); return; }
        copyText(buildRegexEntry(g.name, store.getMetaId(g.key)));
      });
      left.appendChild(copyBtn);

      const right = document.createElement("div"); right.className = "row";
      right.appendChild(span(`${fmtQty(g.qty, g.key)}`, "mono"));

      if (g.reason === "needs-choice" && !g.isBaseOverride) {
        const choose = document.createElement("button"); choose.className = "icon choose-btn"; choose.textContent = "Choose";
        choose.addEventListener("click", () => focusInspectorOnKey(g.key));
        const markBase = document.createElement("button"); markBase.className = "icon"; markBase.textContent = "Mark base";
        markBase.addEventListener("click", () => { baseOverrides.add(g.key); persistAll(); renderAll(); });
        right.append(choose, markBase);
      } else {
        right.appendChild(obtainedControl(g.key));
      }

      const markBtn = document.createElement("button");
      markBtn.className = "icon";

      const canAffectObtained = !g.key.startsWith("tag:");

      if (canAffectObtained) {
        markBtn.textContent = "Mark done";
        markBtn.title = "Mark as obtained (sets Owned to satisfy this requirement)";
        markBtn.addEventListener("click", () => { bumpObtained(g.key, g.qty); });
      } else {
        markBtn.textContent = gatherMarked.has(g.key) ? "Unmark" : "Mark done";
        markBtn.addEventListener("click", () => {
          if (gatherMarked.has(g.key)) gatherMarked.delete(g.key);
          else gatherMarked.add(g.key);
          renderPlan();
        });
      }
      right.appendChild(markBtn);

      const hideBtn = document.createElement("button");
      hideBtn.className = "icon";
      hideBtn.textContent = "Hide item";
      hideBtn.title = "Hide this item from Remaining to gather and from its Regex search output";
      hideBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        setGatherHiddenFlag(g.key, true);
        renderPlan();
      });
      right.appendChild(hideBtn);

      li.append(left, right); ul.appendChild(li);
    }
    gatherSummary.appendChild(ul);
  }

  const children = new Map(); const roots = new Set(planTargets.map(t => t.key));
  for (const e of edges) { if (!children.has(e.parentKey)) children.set(e.parentKey, []); children.get(e.parentKey).push(e); }
  treeArea.innerHTML = "";
  if (!planTargets.length) treeArea.appendChild(p("<span class='muted'>No plan to display.</span>"));
  else {
    const ul = document.createElement("ul");
    for (const root of roots) ul.appendChild(renderNode(root, nodes, children));
    treeArea.appendChild(ul);
  }

  renderTodo({ nodes, edges });
}

function renderNode(key, nodes, children) {
  const node = nodes.get(key) || planner.createNode(key);
  const li = document.createElement("li");
  const head = document.createElement("div"); head.className = "node";

  const hasChildren = children.get(key)?.length > 0;
  const toggle = document.createElement("div"); toggle.className = "toggle"; toggle.textContent = hasChildren ? (planner.openNodes.has(key) ? "▾" : "▸") : "•";
  if (hasChildren) toggle.addEventListener("click", () => { if (planner.openNodes.has(key)) planner.openNodes.delete(key); else planner.openNodes.add(key); renderPlan(); });
  head.appendChild(toggle);

  head.appendChild(itemPill(node.name, key));

  const middle = document.createElement("div");
  const info = [];
  if (node.isBaseOverride) info.push(`<span class="tag">base</span>`);
  else if (node.needsChoice) info.push(`<span class="tag warn">needs recipe</span>`);
  else if (node.recipeId) {
    const r = store.getRecipe(node.recipeId);
    const circ = Array.isArray(r?.circuits) && r.circuits.length ? ` • <span class="tag">Circuit #${r.circuits.join(",")}</span>` : "";
    const machineCls = machineTagClassForOutKey(node.key);
    info.push(`<span class="tag ${machineCls}">${prettyMachine(r)}</span>${circ}`);
    if (node.craftsNeeded > 0) info.push(`<span class="muted">crafts: <span class="mono">${fmtQty(node.craftsNeeded)}</span> × <span class="mono">${fmtQty(node.outPerCraft, key)}</span></span>`);
  } else info.push(`<span class="tag">base</span>`);
  middle.innerHTML = info.join(" ");
  head.appendChild(middle);

  const right = document.createElement("div"); right.className = "row";
  right.appendChild(span(`${fmtQty(node.remaining, key)} / ${fmtQty(node.requested, key)}`, "mono"));
  if (node.needsChoice && !node.isBaseOverride) {
    const choose = document.createElement("button"); choose.className = "icon choose-btn"; choose.textContent = "Choose";
    choose.addEventListener("click", () => focusInspectorOnKey(node.key));
    right.appendChild(choose);
  } else right.appendChild(obtainedControl(key));

  head.appendChild(right);
  li.appendChild(head);

  if (hasChildren && planner.openNodes.has(key)) {
    const ul = document.createElement("ul");
    for (const e of children.get(key)) {
      const childLi = document.createElement("li");
      childLi.appendChild(span(`${ingredientLabel(e.via)} → need ${fmtQty(e.requiredQty)}`, "muted"));
      childLi.appendChild(renderNode(e.childKey, nodes, children));
      ul.appendChild(childLi);
    }
    li.appendChild(ul);
  }
  return li;
}

/* =========================
   To-do (collapsible steps + filters + persistence toggle)
   ========================= */
function renderTodo(build) {
  const B = build || planner.build(); const { edges } = B;
  todoArea.innerHTML = "<div><strong>To‑do</strong> <span class='muted'>(base=1 → final=max; grouped by machine, then name)</span></div>";

  const todoToolbar = document.createElement("div");
  todoToolbar.className = "row";
  todoToolbar.style.margin = "6px 0 8px 0";
  todoToolbar.style.flexWrap = "wrap";

  const btnTodoOrder = document.createElement("button");
  btnTodoOrder.className = "ghost";
  btnTodoOrder.title = "Toggle step order (forward vs reverse)";
  btnTodoOrder.textContent = todoReverse ? "Order: max → 1" : "Order: 1 → max";
  btnTodoOrder.addEventListener("click", () => {
    todoReverse = !todoReverse;
    persistAll();
    renderTodo(build || planner.build());
  });

  const lblCraftable = document.createElement("label");
  lblCraftable.className = "small";
  const chkCraftable = document.createElement("input");
  chkCraftable.type = "checkbox";
  chkCraftable.checked = todoFilterCraftableNow;
  chkCraftable.addEventListener("change", () => {
    todoFilterCraftableNow = chkCraftable.checked;
    persistAll();
    renderTodo(build || planner.build());
  });
  lblCraftable.append(chkCraftable, document.createTextNode("Show only craftable now"));

  const lblHideChecked = document.createElement("label");
  lblHideChecked.className = "small";
  const chkHideChecked = document.createElement("input");
  chkHideChecked.type = "checkbox";
  chkHideChecked.checked = todoFilterHideChecked;
  chkHideChecked.addEventListener("change", () => {
    todoFilterHideChecked = chkHideChecked.checked;
    persistAll();
    renderTodo(build || planner.build());
  });
  lblHideChecked.append(chkHideChecked, document.createTextNode("Hide checked storage"));

  const lblPersist = document.createElement("label");
  lblPersist.className = "small";
  const chkPersist = document.createElement("input");
  chkPersist.type = "checkbox";
  chkPersist.checked = sessionPersistEnabled;
  chkPersist.addEventListener("change", () => {
    setSessionPersistEnabled(chkPersist.checked);
    if (sessionPersistEnabled) persistSessionNow();
  });
  lblPersist.append(chkPersist, document.createTextNode("Persist Owned/Checked"));

  const lblStacks = document.createElement("label");
  lblStacks.className = "small";
  const chkStacks = document.createElement("input");
  chkStacks.type = "checkbox";
  chkStacks.checked = qtyAsStacks;
  chkStacks.addEventListener("change", () => setQtyAsStacksEnabled(chkStacks.checked));
  lblStacks.append(chkStacks, document.createTextNode("Stacks of 64"));

  const btnTodoRegex = document.createElement("button");
  btnTodoRegex.className = "icon";
  btnTodoRegex.textContent = "Copy Regex";
  btnTodoRegex.title = "Copy a compact Regex list for visible To‑do items (excluding Checked Storage)";
  btnTodoRegex.addEventListener("click", () => {
    const again = build || planner.build();
    const craftable = [];
    for (const [k, n] of again.nodes.entries()) {
      if (!(n.recipeId && n.craftsNeeded > 0)) continue;
      const craftsNow = craftsPossibleFor(k, n.recipeId);
      const isChecked = checkedStorage.has(k);

      if (todoFilterHideChecked && isChecked) continue;
      if (todoFilterCraftableNow && craftsNow < n.craftsNeeded) continue;

      craftable.push({ key: k, name: n.name, idNum: store.getMetaId(k) });
    }

    const parts = [];
    for (const it of craftable) {
      if (it.key.startsWith("tag:") || it.key.startsWith("fluid:")) continue;
      if (checkedStorage.has(it.key)) continue;
      parts.push(buildRegexEntry(it.name, it.idNum));
    }
    parts.sort();
    const text = compactJoin(parts);
    if (!text) { toast("Nothing to copy"); return; }
    copyText(text);
  });

  todoToolbar.append(btnTodoOrder, lblCraftable, lblHideChecked, lblPersist, lblStacks, btnTodoRegex);
  todoArea.appendChild(todoToolbar);

  const craftableKeys = new Set();
  for (const [k, n] of B.nodes.entries()) if (n.recipeId && n.craftsNeeded > 0) craftableKeys.add(k);
  if (!craftableKeys.size) { todoArea.appendChild(p("<span class='muted'>No crafting steps pending.</span>")); return; }

  // (rest of To-do unchanged)
  const parentsMap = new Map(); const indeg = new Map(); for (const k of craftableKeys) indeg.set(k, 0);
  for (const e of edges) if (craftableKeys.has(e.parentKey) && craftableKeys.has(e.childKey)) {
    if (!parentsMap.has(e.childKey)) parentsMap.set(e.childKey, []); parentsMap.get(e.childKey).push(e.parentKey);
    indeg.set(e.parentKey, (indeg.get(e.parentKey) || 0) + 1);
  }
  const levels = new Map(); const queue = [];
  for (const [k,d] of indeg.entries()) if (d===0) { queue.push(k); levels.set(k,1); }
  while (queue.length) {
    const k = queue.shift();
    for (const p of (parentsMap.get(k) || [])) {
      const nextL = (levels.get(k) || 1) + 1; levels.set(p, Math.max(levels.get(p) || 1, nextL));
      indeg.set(p, indeg.get(p) - 1); if (indeg.get(p) === 0) queue.push(p);
    }
  }
  let maxL=1; for (const v of levels.values()) maxL=Math.max(maxL,v); for (const k of craftableKeys) if (!levels.has(k)) levels.set(k,maxL+1);

  const allSteps = [];
  for (const k of craftableKeys) {
    const n = B.nodes.get(k);
    const r = store.getRecipe(n.recipeId);
    const craftsNow = craftsPossibleFor(k, n.recipeId);
    const isChecked = checkedStorage.has(k);

    allSteps.push({
      key:k,
      name:n.name,
      machine: prettyMachine(r),
      level: levels.get(k)||1,
      crafts:n.craftsNeeded,
      outPerCraft:n.outPerCraft,
      totalOut:n.craftsNeeded*n.outPerCraft,
      recipeId:n.recipeId,
      remaining:n.remaining,
      craftsNow,
      isChecked
    });
  }

  const visibleSteps = allSteps.filter(s => {
    if (todoFilterHideChecked && s.isChecked) return false;
    if (todoFilterCraftableNow && s.craftsNow < s.crafts) return false;
    return true;
  });

  if (!visibleSteps.length) {
    todoArea.appendChild(p("<span class='muted'>No To‑do items match your current filters.</span>"));
    return;
  }

  visibleSteps.sort((a,b)=> {
    if (a.level !== b.level) return todoReverse ? (b.level - a.level) : (a.level - b.level);
    const mc = a.machine.localeCompare(b.machine);
    if (mc) return mc;
    return a.name.localeCompare(b.name);
  });

  const levelsPresent = Array.from(new Set(visibleSteps.map(s => s.level)));
  levelsPresent.sort((a,b) => todoReverse ? (b-a) : (a-b));
  const currentLevelSuggested = levelsPresent[0];

  const btnExpandAll = document.createElement("button");
  btnExpandAll.className = "ghost";
  btnExpandAll.textContent = "Expand all";
  btnExpandAll.addEventListener("click", () => {
    todoCollapsedLevels.clear();
    persistAll();
    renderTodo(build || planner.build());
  });

  const btnCollapseAll = document.createElement("button");
  btnCollapseAll.className = "ghost";
  btnCollapseAll.textContent = "Collapse all";
  btnCollapseAll.addEventListener("click", () => {
    todoCollapsedLevels = new Set(levelsPresent);
    persistAll();
    renderTodo(build || planner.build());
  });

  const btnFocusCurrent = document.createElement("button");
  btnFocusCurrent.className = "ghost";
  btnFocusCurrent.textContent = "Focus current step";
  btnFocusCurrent.title = "Collapse everything except the next step to work on (based on current order + filters)";
  btnFocusCurrent.addEventListener("click", () => {
    todoCollapsedLevels = new Set(levelsPresent.filter(l => l !== currentLevelSuggested));
    persistAll();
    renderTodo(build || planner.build());
    const el = document.getElementById(`todo-level-${currentLevelSuggested}`);
    el?.scrollIntoView({ behavior: "smooth", block: "start" });
  });

  const controlsRow = document.createElement("div");
  controlsRow.className = "row";
  controlsRow.style.margin = "0 0 8px 0";
  controlsRow.style.flexWrap = "wrap";
  controlsRow.append(btnFocusCurrent, btnExpandAll, btnCollapseAll);
  todoArea.appendChild(controlsRow);

  let currentLevel = null;

  const levelStats = new Map();
  for (const s of visibleSteps) {
    if (!levelStats.has(s.level)) levelStats.set(s.level, { total:0, craftableNow:0, checked:0 });
    const st = levelStats.get(s.level);
    st.total += 1;
    if (s.craftsNow >= s.crafts) st.craftableNow += 1;
    if (s.isChecked) st.checked += 1;
  }

  for (const s of visibleSteps) {
    if (s.level !== currentLevel) {
      currentLevel = s.level;

      const hdr = document.createElement("div");
      hdr.className = "level-title";
      hdr.id = `todo-level-${currentLevel}`;

      const levelForThisHeader = currentLevel;
      const titleText = levelForThisHeader===1 ? "Step 1 (base)" : `Step ${levelForThisHeader}`;
      const isCollapsed = todoCollapsedLevels.has(levelForThisHeader);

      const st = levelStats.get(levelForThisHeader) || { total:0, craftableNow:0, checked:0 };
      const countsText = `(${st.total} item${st.total===1?"":"s"}${todoFilterCraftableNow ? "" : ` • ${st.craftableNow} craftable now`})`;

      const levelHeader = document.createElement("div");
      levelHeader.className = "levelHeader";

      const toggleWrap = document.createElement("span");
      toggleWrap.className = "levelToggle";
      const btnToggle = document.createElement("button");
      btnToggle.className = "icon";
      btnToggle.title = isCollapsed ? "Expand this step" : "Collapse this step";
      btnToggle.textContent = isCollapsed ? "▸" : "▾";
      btnToggle.addEventListener("click", () => {
        if (todoCollapsedLevels.has(levelForThisHeader)) todoCollapsedLevels.delete(levelForThisHeader);
        else todoCollapsedLevels.add(levelForThisHeader);
        persistAll();
        renderTodo(build || planner.build());
      });
      toggleWrap.appendChild(btnToggle);

      const titleSpan = document.createElement("span");
      titleSpan.textContent = `${titleText} `;
      titleSpan.style.cursor = "pointer";
      titleSpan.title = "Click to collapse/expand this step";
      titleSpan.addEventListener("click", () => btnToggle.click());

      const countSpan = document.createElement("span");
      countSpan.className = "muted";
      countSpan.textContent = countsText;

      const btnStepRegex = document.createElement("button");
      btnStepRegex.className = "icon";
      btnStepRegex.textContent = "Copy Regex";
      btnStepRegex.title = `Copy a compact Regex list for visible items in ${titleText} (excluding Checked Storage)`;
      btnStepRegex.addEventListener("click", () => {
        const levelParts = [];
        for (const s2 of visibleSteps) {
          if (s2.level !== levelForThisHeader) continue;
          const k = s2.key;
          if (k.startsWith("tag:") || k.startsWith("fluid:")) continue;
          if (checkedStorage.has(k)) continue;
          const idNum = store.getMetaId(k);
          levelParts.push(buildRegexEntry(s2.name, idNum));
        }
        levelParts.sort();
        const text = compactJoin(levelParts);
        if (!text) { toast("Nothing to copy for this step"); return; }
        copyText(text);
      });

      levelHeader.append(toggleWrap, titleSpan, countSpan, btnStepRegex);
      hdr.appendChild(levelHeader);
      todoArea.appendChild(hdr);
    }

    if (todoCollapsedLevels.has(s.level)) continue;

    const step = document.createElement("div"); step.className = "step";

    if (s.craftsNow >= s.crafts) step.classList.add("craftable-now");
    else if (s.craftsNow >= 1) step.classList.add("partially-craftable");
    if (checkedStorage.has(s.key)) step.classList.add("checked-storage");

    if (ingredientFocusKey && recipeUsesKey(store.getRecipe(s.recipeId), s.key, ingredientFocusKey)) step.classList.add("ingredient-focus");

    const left = document.createElement("div"); left.className = "meta"; left.addEventListener("click", () => focusInspectorOnKey(s.key));
    const need = Math.max(0, (B.nodes.get(s.key)?.remaining) || 0);
    const r = store.getRecipe(s.recipeId);
    const circuitBadge = Array.isArray(r?.circuits) && r.circuits.length ? ` Circuit #${r.circuits.join(",")}` : "";
    left.appendChild(itemPill(`${fmtQty(need, s.key)}x ${s.name}`, s.key));

    left.appendChild(tagEl(s.machine, machineTagClassForOutKey(s.key)));
    if (circuitBadge) left.appendChild(tagEl(circuitBadge));

    const copyBtn = document.createElement("button"); copyBtn.className = "icon"; copyBtn.title = `Copy “${s.name}”`; copyBtn.textContent = "Copy";
    copyBtn.addEventListener("click", (ev) => { ev.stopPropagation(); copyText(s.name); });
    left.appendChild(copyBtn);

    left.appendChild(span(`<span class="muted">crafts: <span class="mono">${fmtQty(s.crafts)}</span> × <span class="mono">${fmtQty(s.outPerCraft, s.key)}</span> → <span class="mono">${fmtQty(s.totalOut, s.key)}</span></span>`, ""));
    step.appendChild(left);

    const right = document.createElement("div"); right.className = "right";
    const ownedWrap = document.createElement("label"); ownedWrap.className = "small"; ownedWrap.textContent = "Owned:";
    const ownedInput = document.createElement("input"); ownedInput.type = "number"; ownedInput.className = "owned"; ownedInput.min="0"; ownedInput.step="1"; ownedInput.value = obtainedNumber(s.key);
    ownedInput.addEventListener("change", () => {
      const val = Math.max(0, Math.floor(Number(ownedInput.value)||0));
      setObtainedValue(s.key, val);
      renderAll();
    });
    ownedWrap.appendChild(ownedInput);
    right.appendChild(ownedWrap);

    const chkWrap = document.createElement("label"); chkWrap.className = "small"; chkWrap.textContent = "Checked Storage";
    const chk = document.createElement("input"); chk.type = "checkbox"; chk.checked = checkedStorage.has(s.key);
    chk.addEventListener("change", () => {
      setCheckedStorageFlag(s.key, chk.checked);
      renderPlan();
    });
    chkWrap.prepend(chk);
    right.appendChild(chkWrap);

    const needLabel = document.createElement("span"); needLabel.className = "small"; needLabel.innerHTML = `Need: <span class="mono">${fmtQty(need, s.key)}</span>`;
    right.appendChild(needLabel);

    const btnOne = document.createElement("button"); btnOne.className = "icon"; btnOne.textContent = "+1 craft"; btnOne.title = `Add ${s.outPerCraft} obtained`;
    btnOne.addEventListener("click", () => { bumpObtained(s.key, s.outPerCraft); });

    const btnAll = document.createElement("button"); btnAll.className = "primary"; btnAll.textContent = "Mark done"; btnAll.title = `Add ${need} obtained`;
    btnAll.addEventListener("click", () => { bumpObtained(s.key, need); });

    right.append(btnOne, btnAll);

    step.appendChild(right);
    todoArea.appendChild(step);
  }
}

function bumpObtained(key, delta) {
  bumpObtainedValue(key, delta);
  renderAll();
}

// DOM helpers
function p(html) { const el = document.createElement("p"); el.innerHTML = html; return el; }
function span(text, cls) { const s = document.createElement("span"); s.innerHTML = text; if (cls) s.className = cls; return s; }
function tagEl(text, cls){ const e = document.createElement("span"); e.className = `tag${cls ? " "+cls : ""}`; e.textContent = text; return e; }
function itemPill(name, key) {
  const d = document.createElement("div"); d.className = "pill";
  const hue = (hashCode(key) % 360 + 360) % 360;
  const emblem = document.createElement("span"); Object.assign(emblem.style, { display:"inline-block", width:"12px", height:"12px", borderRadius:"3px", background:`hsl(${hue} 70% 45%)` });
  d.appendChild(emblem);
  const label = document.createElement("span"); label.textContent = name; d.appendChild(label);

  if (store.outputsFor(key).length) {
    const { activeId, idealId, match } = favPairFor(key);

    const starA = document.createElement("span");
    const isFavA = !!activeId;
    starA.className = "fav"; starA.title = isFavA ? "ACTIVE recipe selected" : "Click to select ACTIVE recipe";
    starA.textContent = isFavA ? "★" : "☆";
    starA.style.color = match ? "var(--match)" : "var(--active)";
    starA.addEventListener("click", (e) => { e.stopPropagation(); pickFavoriteViaDialog(key, { mode: "active" }); });
    d.appendChild(starA);

    const starI = document.createElement("span");
    const isFavI = !!idealId;
    starI.className = "fav"; starI.title = isFavI ? "IDEAL recipe bookmarked" : "Click to select IDEAL recipe (bookmark only)";
    starI.textContent = isFavI ? "★" : "☆";
    starI.style.color = match ? "var(--match)" : "var(--ideal)";
    starI.addEventListener("click", (e) => { e.stopPropagation(); pickFavoriteViaDialog(key, { mode: "ideal" }); });
    d.appendChild(starI);
  }
  return d;
}
function obtainedControl(key) {
  const wrap = document.createElement("div"); wrap.className = "row";
  const minus = document.createElement("button"); minus.className = "icon"; minus.textContent = "−";
  const input = document.createElement("input"); input.type = "number"; input.min = "0";
  const plus = document.createElement("button"); plus.className = "icon"; plus.textContent = "+";

  const step = stepForKey(key);
  input.step = String(step);
  input.value = obtainedNumber(key);

  minus.addEventListener("click", () => {
    const cur = obtainedNumber(key);
    const next = Math.max(0, cur - step);
    setObtainedValue(key, next);
    renderPlan();
  });
  plus.addEventListener("click", () => {
    const cur = obtainedNumber(key);
    const next = cur + step;
    setObtainedValue(key, next);
    renderPlan();
  });
  input.addEventListener("change", () => {
    let val = Math.max(0, Math.floor(Number(input.value) || 0));
    setObtainedValue(key, val);
    renderPlan();
  });

  wrap.append(minus, input, plus);
  return wrap;
}
function obtainedNumber(key) { return Number(obtained.get(key) || 0); }

/**
 * Hidden-as-done:
 * If an entry is in Hidden Items list, treat it as satisfied up to needed amount.
 */
function planningHave(key, needed = 0) {
  const have = obtainedNumber(key);
  if (gatherHiddenKeys.has(key)) return Math.max(have, needed);
  return have;
}

/* Favorite selector modal */
function pickFavoriteViaDialog(outKey, { mode = "active" } = {}) {
  const recipes = store.outputsFor(outKey).map(id => ({ id, r: store.getRecipe(id) }));
  const labelMode = mode === "ideal" ? "IDEAL" : "ACTIVE";
  const { activeId, idealId, match } = favPairFor(outKey);
  const selectedId = (mode === "ideal") ? (idealId || "") : (activeId || "");

  openModal(`Choose ${labelMode} recipe for ${store.getItemName(outKey)}`, (body) => {
    if (mode === "ideal") body.appendChild(p("<span class='muted'>IDEAL is a bookmark only and does not affect planning.</span>"));
    else body.appendChild(p("<span class='muted'>ACTIVE is used in planning calculations.</span>"));

    const list = document.createElement("div"); list.style.display = "flex"; list.style.flexDirection = "column"; list.style.gap = "6px";
    for (const {id, r} of recipes) {
      const row = document.createElement("div"); row.className = "row space recipe-row";
      const isSelected = !!(selectedId && id === selectedId);
      const isMatchSelected = match && isSelected && activeId && idealId && id === activeId;

      if (isSelected) {
        row.classList.add(
          isMatchSelected ? "selected-match" :
          mode === "ideal" ? "selected-ideal" : "selected-active"
        );
      }

      const left = document.createElement("div"); left.className = "row";
      const circ = Array.isArray(r.circuits) && r.circuits.length ? ` • Circuit #${r.circuits.join(",")}` : "";
      left.appendChild(tagEl(prettyMachine(r), (isMatchSelected ? "match" : (mode === "ideal" ? "ideal" : "active"))));
      left.appendChild(span(`yields ${fmtQty((r.outputs[0]?.count)||1)} • ${summInputs(r)}${circ}`));
      if (isSelected) left.appendChild(tagEl("selected", isMatchSelected ? "match" : (mode === "ideal" ? "ideal" : "active")));

      const right = document.createElement("div");
      const use = document.createElement("button"); use.className = "icon"; use.textContent = "Use";
      use.style.color = isMatchSelected ? "var(--match)" : (mode === "ideal" ? "var(--ideal)" : "var(--active)");
      use.addEventListener("click", () => {
        if (mode === "ideal") favoritesIdeal.set(outKey, id);
        else favorites.set(outKey, id);
        persistAll(); closeModal(); renderAll();
      });
      right.appendChild(use);
      row.append(left, right); list.appendChild(row);
    }
    body.appendChild(list);
  }, (foot) => {
    const clear = document.createElement("button"); clear.className = "ghost"; clear.textContent = "Clear";
    clear.addEventListener("click", () => {
      if (mode === "ideal") favoritesIdeal.delete(outKey);
      else favorites.delete(outKey);
      persistAll(); closeModal(); renderAll();
    });
    const close = document.createElement("button"); close.className = "icon"; close.textContent = "Close";
    close.addEventListener("click", closeModal);
    foot.appendChild(clear);
    foot.appendChild(close);
  });
}

/* Clipboard */
async function copyText(text) {
  try { await navigator.clipboard.writeText(text); toast("Copied to clipboard"); }
  catch {
    const ta = document.createElement("textarea");
    ta.value = text; document.body.appendChild(ta); ta.select();
    document.execCommand("copy"); ta.remove();
    toast("Copied to clipboard");
  }
}

/* RecEx normalizer (unchanged) */
const ANY_CIRCUIT_TAGS = new Map([
  ["any ulv circuit","circuitPrimitive"],
  ["any lv circuit","circuitBasic"],
  ["any mv circuit","circuitGood"],
  ["any hv circuit","circuitAdvanced"],
  ["any ev circuit","circuitData"],
  ["any iv circuit","circuitElite"],
  ["any luv circuit","circuitMaster"],
  ["any zpm circuit","circuitUltimate"],
  ["any uv circuit","circuitSuperconductor"],
  ["any uhv circuit","circuitInfinite"],
  ["any uev circuit","circuitBio"],
  ["any uiv circuit","circuitOptical"],
  ["any umv circuit","circuitExotic"],
  ["any uxv circuit","circuitCosmic"],
  ["any max circuit","circuitTranscendent"],
]);

function canonIngredient(ing) { if (ing.tag) return `tag:${ing.tag}#${ing.count||1}`; const key = ing.key || keyOf(ing.item, ing.meta || 0); return `item:${key}#${ing.count||1}#${ing.unit||"item"}`; }
function canonOutput(out) { const key = out.key || keyOf(out.item, out.meta || 0); return `item:${key}#${out.count||1}#${out.unit||"item"}`; }
function stableIdForRecipe(type, machine, inputs, outputs) { const sInputs = inputs.map(canonIngredient).sort().join("|"); const sOutputs = outputs.map(canonOutput).sort().join("|"); const core = `${type}|${machine||""}|${sInputs}=>${sOutputs}`; return `${type}/${stableHashHex(core)}`; }

// (normalizeFromRecEx + importRecExFile + zip helpers unchanged from your version)
function canonKeyOfMeta(id, m = 0) { return m ? `${id}@${m|0}` : id; }
function normalizeFromRecEx(raw, opts) {
  const itemsMap = new Map(); const tags = new Map(); const recipes = [];
  const addItem = (key, displayName, metaId) => {
    if (!key) return;
    if (!itemsMap.has(key)) itemsMap.set(key, { displayName, metaId: (typeof metaId === "number" ? metaId : undefined) });
    else {
      const it = itemsMap.get(key);
      if (typeof metaId === "number" && typeof it.metaId !== "number") it.metaId = metaId;
      if (!it.displayName && displayName) it.displayName = displayName;
    }
  };
  const addTagItem = (tag, itemKey) => { if (!tag) return; if (!tags.has(tag)) tags.set(tag, new Set()); tags.get(tag).add(itemKey); };

  const isProgrammedCircuit = (obj) => {
    const id = (obj?.uN || obj?.id || "").toLowerCase();
    const name = (obj?.lN || "").toLowerCase();
    return id.includes("integrated_circuit") || /programmed\s*circuit/.test(name);
  };

  function detectAnyCircuitTagNameLike(obj) {
    const label = String(obj?.lN || obj?.uN || "").trim().toLowerCase();
    const normalized = label.replace(/\s+/g, " ");
    return ANY_CIRCUIT_TAGS.get(normalized) || null;
  }

  const parseItemLike = (obj, { asOutput = false } = {}) => {
    if (!obj || typeof obj !== "object") return null;

    const circuitTag = detectAnyCircuitTagNameLike(obj);
    if (circuitTag) return { tag: circuitTag, count: Math.max(1, (obj.a | 0) || 1) };

    if ("dns" in obj && Array.isArray(obj.dns)) {
      const tag = String(obj.dns[0] || "");
      const ims = Array.isArray(obj.ims) ? obj.ims : [];
      let count = 1; if (ims.length && typeof ims[0]?.a === "number") count = (ims[0].a | 0) || 1;

      for (const im of ims) {
        if (im?.uN) { const key = im.uN; addItem(key, im.lN || im.uN); addTagItem(tag, key); }
        else if (im?.id) { const key = canonKeyOfMeta(im.id, im.m || 0); addItem(key, im.lN || `${im.id}${im.m ? ` [${im.m}]` : ""}`, typeof im.m === "number" ? im.m : undefined); addTagItem(tag, key); }
      }

      if (asOutput && ims.length) {
        const first = ims[0];
        if (first?.uN) { const key = first.uN; addItem(key, first.lN || first.uN); return { item: key, key, count: Math.max(1, count), unit: "item" }; }
        if (first?.id) { const key = canonKeyOfMeta(first.id, first.m || 0); addItem(key, first.lN || `${first.id}${first.m ? ` [${first.m}]` : ""}`, typeof first.m === "number" ? first.m : undefined); return { item: key, key, count: Math.max(1, count), unit: "item" }; }
      }
      return { tag, count: Math.max(1, count) };
    }

    if (isProgrammedCircuit(obj) && !opts.consumeCircuits) return null;

    if (obj.uN) {
      const key = obj.uN; const count = Math.max(1, (obj.a | 0) || 1);
      addItem(key, obj.lN || key);
      return { item: key, key, count, unit: "item" };
    }
    if (obj.id) {
      const key = canonKeyOfMeta(obj.id, obj.m || 0); const count = Math.max(1, (obj.a | 0) || 1);
      const name = obj.lN || `${obj.id}${obj.m ? ` [${obj.m}]` : ""}`;
      addItem(key, name, typeof obj.m === "number" ? obj.m : undefined);
      return { item: key, key, count, unit: "item" };
    }
    return null;
  };

  const parseFluid = (obj) => {
    if (!obj || typeof obj !== "object") return null;
    const rawId = obj.uN || obj.id || obj.lN || "";
    const key = `fluid:${rawId}`;
    const count = Math.max(1, (obj.a | 0) || 1);
    addItem(key, obj.lN || rawId);
    return { item: key, key, count, unit: "mB" };
  };

  const pushRecipe = (rec) => { if (!rec.outputs?.length) return; rec.id = rec.id || `r_${uid()}`; recipes.push(rec); };

  const collectCircuitsFromObj = (o, into) => {
    if (!o || typeof o !== "object") return;
    const candidates = ["cfg", "circuit", "circuits", "pc", "config", "configNumber"];
    for (const k of candidates) {
      const v = o[k];
      if (typeof v === "number" && Number.isFinite(v)) into.push(v|0);
      else if (Array.isArray(v)) for (const n of v) if (Number.isFinite(Number(n))) into.push(Number(n)|0);
      else if (typeof v === "string" && v.trim() !== "" && Number.isFinite(Number(v))) into.push(Number(v)|0);
    }
  };

  const sources = Array.isArray(raw.sources) ? raw.sources : [];
  let gtMachineIdx = 0;

  for (const src of sources) {
    const type = (src.type || (Array.isArray(src.machines) ? "gregtech" : "")).toString();

    if (type === "gregtech") {
      const machines = Array.isArray(src.machines) ? src.machines : [];
      for (const m of machines) {
        const machineName = m.n || "gregtech";
        const recs = Array.isArray(m.recs) ? m.recs : [];
        let recIdx = 0;
        for (const r of recs) {
          recIdx++;
          if (r && r.en === false) continue;

          const inputs = []; const outputs = [];
          const circuitNumbers = [];
          collectCircuitsFromObj(r, circuitNumbers);

          for (const it of (Array.isArray(r.iI) ? r.iI : [])) {
            if (isProgrammedCircuit(it) && Number.isFinite(Number(it.m))) circuitNumbers.push(Number(it.m)|0);
            collectCircuitsFromObj(it, circuitNumbers);
            const ing = parseItemLike(it, { asOutput: false }); if (ing) inputs.push(ing);
          }
          for (const it of (Array.isArray(r.iO) ? r.iO : [])) {
            const out = parseItemLike(it, { asOutput: true });
            if (out) {
              if (out.tag) outputs.push({ item: `tag:${out.tag}`, key: `tag:${out.tag}`, count: out.count, unit: "item" });
              else outputs.push({ item: out.item, key: out.key, count: Math.max(1, out.count || 1), unit: "item" });
            }
          }

          for (const fl of (Array.isArray(r.fI) ? r.fI : [])) { const ing = parseFluid(fl); if (ing) inputs.push(ing); }
          for (const fl of (Array.isArray(r.fO) ? r.fO : [])) { const out = parseFluid(fl); if (out) outputs.push(out); }

          if (!outputs.length) continue;

          pushRecipe({
            id: `gt:${machineName}/${gtMachineIdx}_${recIdx}`,
            type: "gregtech", machine: machineName,
            euPerTick: (typeof r.eut === "number") ? r.eut : null,
            duration: (typeof r.dur === "number") ? r.dur : null,
            inputs, outputs, circuits: Array.from(new Set(circuitNumbers))
          });
        }
        gtMachineIdx++;
      }
    } else if (type === "shaped" || type === "shapeless" || type === "shapedOreDict") {
      const recipesArr = Array.isArray(src.recipes) ? src.recipes : [];
      for (const r of recipesArr) {
        const inputs = [];
        for (const it of (Array.isArray(r.iI) ? r.iI : [])) { const ing = parseItemLike(it, { asOutput: false }); if (ing) inputs.push(ing); }
        const outputs = [];
        if (r.o) {
          const out = parseItemLike(r.o, { asOutput: true });
          if (out) {
            if (out.tag) outputs.push({ item: `tag:${out.tag}`, key: `tag:${out.tag}`, count: out.count, unit: "item" });
            else outputs.push({ item: out.item, key: out.key, count: Math.max(1, out.count || 1), unit: "item" });
          }
        }
        if (!outputs.length) continue;

        const idStable = stableIdForRecipe(type, type, inputs, outputs);
        pushRecipe({ id: idStable, type, machine: type, inputs, outputs });
      }
    }
  }

  const items = Array.from(itemsMap.entries()).map(([key, v]) => {
    const [id, metaStr] = key.split("@");
    const meta = metaStr ? Number(metaStr) : 0;
    const obj = { id, meta, displayName: v.displayName };
    if (typeof v.metaId === "number") obj.metaId = v.metaId;
    return obj;
  });
  const tagsObj = {}; for (const [tag, set] of tags.entries()) tagsObj[tag] = Array.from(set);
  return { items, tags: tagsObj, recipes };
}

async function importRecExFile(file) {
  if (file.name.endsWith(".zip")) {
    showProgress("Reading ZIP…", 0);
    const buf = new Uint8Array(await file.arrayBuffer());
    const entries = await listJsonEntriesFromZip(buf);
    if (!entries.length) throw new Error("No .json or .json.gz found in ZIP");
    let merged = null; let processed = 0;
    for (const ent of entries) {
      processed++;
      showProgress(`Reading ${ent.name} (${processed}/${entries.length})`, processed / entries.length);
      let data;
      if (ent.name.endsWith(".gz") || ent.name.endsWith(".json.gz"))
        data = await gunzip(ent.data, (p) => showProgress(`Decompressing ${ent.name}… ${Math.round(p*100)}%`, (processed - 1 + p) / entries.length));
      else if (ent.compression === 0) data = ent.data;
      else if (ent.compression === 8)
        data = await inflateRaw(ent.data, (p) => showProgress(`Inflating ${ent.name}… ${Math.round(p*100)}%`, (processed - 1 + p) / entries.length));
      else { console.warn(`Skipping ${ent.name}: unsupported compression ${ent.compression}`); continue; }
      const text = new TextDecoder().decode(data);
      const doc = safeParseJSON(text);
      if (!doc || !Array.isArray(doc.sources)) continue;
      merged = merged ? mergeRecExDocs(merged, doc) : doc;
    }
    if (!merged) throw new Error("No valid RecEx export JSON found in ZIP");
    await parseRecExObject(merged);
  } else if (file.name.endsWith(".gz") || file.type === "application/gzip") {
    showProgress("Decompressing GZIP…", 0);
    const data = await gunzip(new Uint8Array(await file.arrayBuffer()), (p) => showProgress(`Decompressing… ${Math.round(p*100)}%`, p));
    const text = new TextDecoder().decode(data);
    const obj = safeParseJSON(text);
    if (!obj || !Array.isArray(obj.sources)) throw new Error("Invalid RecEx JSON");
    await parseRecExObject(obj);
  } else {
    showProgress("Reading JSON…", 0);
    const text = await file.text();
    const obj = safeParseJSON(text);
    if (!obj || !Array.isArray(obj.sources)) throw new Error("Invalid RecEx JSON");
    await parseRecExObject(obj);
  }
  hideProgress();
  toast(`Loaded ${store.items.size} items, ${store.recipes.size} recipes`);
  renderAll();
}
function safeParseJSON(text) { try { return JSON.parse(text); } catch { return null; } }
async function parseRecExObject(raw) {
  showProgress("Normalizing recipes…", 0.1);
  const norm = normalizeFromRecEx(raw, { consumeCircuits: circuitsConsumed });
  store.importNormalized(norm);
  hideProgress();
}
function mergeRecExDocs(a, b) {
  const out = { sources: [] };
  if (Array.isArray(a.sources)) out.sources.push(...a.sources);
  if (Array.isArray(b.sources)) out.sources.push(...b.sources);
  return out;
}

// ZIP helpers
async function listJsonEntriesFromZip(u8) {
  const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
  const EOCD = 0x06054b50, CEN = 0x02014b50, LOC = 0x04034b50;
  const maxComment = Math.min(0xFFFF, u8.length);
  let eocdPos = -1;
  for (let i = u8.length - 22; i >= Math.max(0, u8.length - 22 - maxComment); i--)
    if (dv.getUint32(i, true) === EOCD) { eocdPos = i; break; }
  if (eocdPos < 0) throw new Error("ZIP: End of Central Directory not found");
  const totalEntries = dv.getUint16(eocdPos + 10, true);
  const cenOffset = dv.getUint32(eocdPos + 16, true);

  const entries = [];
  let ptr = cenOffset;
  for (let i = 0; i < totalEntries; i++) {
    if (dv.getUint32(ptr, true) !== CEN) throw new Error("ZIP: Central directory bad signature");
    const compMethod = dv.getUint16(ptr + 10, true);
    const compSize = dv.getUint32(ptr + 20, true);
    const nameLen = dv.getUint16(ptr + 28, true);
    const extraLen = dv.getUint16(ptr + 30, true);
    const commentLen = dv.getUint16(ptr + 32, true);
    const lfhOff = dv.getUint32(ptr + 42, true);
    const nameBytes = u8.subarray(ptr + 46, ptr + 46 + nameLen);
    const name = new TextDecoder().decode(nameBytes);
    ptr += 46 + nameLen + extraLen + commentLen;

    const isJsonish = /\.json(\.gz)?$/i.test(name);
    const isSchema = /schema\.json$/i.test(name);
    if (!isJsonish || isSchema) continue;

    if (dv.getUint32(lfhOff, true) !== LOC) throw new Error("ZIP: Local file header bad signature");
    const lfNameLen = dv.getUint16(lfhOff + 26, true);
    const lfExtraLen = dv.getUint16(lfhOff + 28, true);
    const dataStart = lfhOff + 30 + lfNameLen + lfExtraLen;
    const compData = u8.subarray(dataStart, dataStart + compSize);

    entries.push({ name, compression: compMethod, compSize, data: compData });
  }
  entries.sort((a,b)=>a.name.localeCompare(b.name));
  return entries;
}
async function inflateRaw(u8, onProgress) {
  if (!supportsDecompressionStream) throw new Error("Your browser lacks DecompressionStream for deflate-raw.");
  const ds = new DecompressionStream('deflate-raw');
  const stream = new Blob([u8]).stream().pipeThrough(ds);
  return await readStreamToUint8Array(stream, onProgress, u8.byteLength);
}
async function gunzip(u8, onProgress) {
  if (!supportsDecompressionStream) throw new Error("Your browser lacks DecompressionStream for gzip.");
  const ds = new DecompressionStream('gzip');
  const stream = new Blob([u8]).stream().pipeThrough(ds);
  return await readStreamToUint8Array(stream, onProgress, u8.byteLength);
}
async function readStreamToUint8Array(stream, onProgress, totalHint) {
  const reader = stream.getReader(); const chunks = []; let received = 0;
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    chunks.push(value); received += value.byteLength;
    if (onProgress && totalHint) onProgress(received / totalHint);
  }
  const out = new Uint8Array(received); let offset = 0;
  for (const c of chunks) { out.set(c, offset); offset += c.byteLength; }
  if (onProgress) onProgress(1);
  return out;
}

// Download helper
function downloadBlob(blob, filename) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}

// Demo data
const DEMO_DATA = {
  items: [
    { id: "gt:circuit_electronic", displayName: "Electronic Circuit" },
    { id: "gt:board_primitive", displayName: "Primitive Circuit Board" },
    { id: "gt:plate_tin", displayName: "Tin Plate" },
    { id: "minecraft:redstone", displayName: "Redstone Dust" },
    { id: "gt:wire_copper_fine", displayName: "Fine Copper Wire" },
    { id: "gt:ingot_copper", displayName: "Copper Ingot" },
    { id: "gt:ingot_tin", displayName: "Tin Ingot" },
    { id: "fluid:soldering_alloy", displayName: "soldering_alloy" }
  ],
  tags: {},
  recipes: []
};

// Toast + focus
let toastTimer = null;
function toast(msg) {
  let el = document.getElementById("toast");
  if (!el) {
    el = document.createElement("div");
    el.id = "toast";
    Object.assign(el.style, {
      position:"fixed", bottom:"16px", right:"16px",
      background:"#111a", backdropFilter:"blur(6px)",
      border:"1px solid var(--border)", padding:"10px 12px",
      borderRadius:"8px", zIndex:"9999", transition:"opacity .2s ease"
    });
    document.body.appendChild(el);
  }
  el.textContent = msg; el.style.opacity = "1";
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => { el.style.opacity = "0"; }, 1800);
}
function focusInspectorOnKey(key) {
  planner.selectedKey = key;
  renderInspector();
  document.getElementById("inspectorPanel").scrollIntoView({ behavior: "smooth", block: "start" });
}

// Init
setLeftTab(leftTab);
updateCollapseUI();
applyColumnSizes();
persistAll();
renderAll();
updateHiddenItemsButton();
updateBaseItemsButton();
toast("Load your RecEx ZIP or JSON via the file picker at the top.");
</script>
</body>
</html>